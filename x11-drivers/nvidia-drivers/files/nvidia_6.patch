diff -ruN a/kernel/common/inc/nv-linux.h.orig b/kernel/common/inc/nv-linux.h.orig
--- a/kernel/common/inc/nv-linux.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ b/kernel/common/inc/nv-linux.h.orig	2020-07-10 15:52:18.369263824 +0200
@@ -0,0 +1,1903 @@
+/* _NVRM_COPYRIGHT_BEGIN_
+ *
+ * Copyright 2001-2020 by NVIDIA Corporation.  All rights reserved.  All
+ * information contained herein is proprietary and confidential to NVIDIA
+ * Corporation.  Any use, reproduction, or disclosure without the written
+ * permission of NVIDIA Corporation is prohibited.
+ *
+ * _NVRM_COPYRIGHT_END_
+ */
+
+#ifndef _NV_LINUX_H_
+#define _NV_LINUX_H_
+
+#include "nvstatus.h"
+#include "nv-misc.h"
+#include "nv.h"
+#include "conftest.h"
+
+#include "nv-lock.h"
+#include "nv-pgprot.h"
+#include "nv-mm.h"
+#include "os-interface.h"
+#include "nv-timer.h"
+#include "nv-caps.h"
+
+#define NV_KERNEL_NAME "Linux"
+
+#ifndef AUTOCONF_INCLUDED
+#if defined(NV_GENERATED_AUTOCONF_H_PRESENT)
+#include <generated/autoconf.h>
+#else
+#include <linux/autoconf.h>
+#endif
+#endif
+
+#if defined(NV_GENERATED_UTSRELEASE_H_PRESENT)
+  #include <generated/utsrelease.h>
+#endif
+
+#if defined(NV_GENERATED_COMPILE_H_PRESENT)
+  #include <generated/compile.h>
+#endif
+
+#include <linux/version.h>
+#include <linux/utsname.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+#error "This driver does not support kernels older than 2.6.32!"
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 7, 0)
+#  define KERNEL_2_6
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+#  define KERNEL_3
+#else
+#error "This driver does not support development kernels!"
+#endif
+
+#if defined (CONFIG_SMP) && !defined (__SMP__)
+#define __SMP__
+#endif
+
+#if defined (CONFIG_MODVERSIONS) && !defined (MODVERSIONS)
+#  define MODVERSIONS
+#endif
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <asm/bug.h>
+
+#include <linux/mm.h>
+
+#if !defined(VM_RESERVED)
+#define VM_RESERVED    0x00000000
+#endif
+#if !defined(VM_DONTEXPAND)
+#define VM_DONTEXPAND  0x00000000
+#endif
+#if !defined(VM_DONTDUMP)
+#define VM_DONTDUMP    0x00000000
+#endif
+
+#include <linux/init.h>             /* module_init, module_exit         */
+#include <linux/types.h>            /* pic_t, size_t, __u32, etc        */
+#include <linux/errno.h>            /* error codes                      */
+#include <linux/list.h>             /* circular linked list             */
+#include <linux/stddef.h>           /* NULL, offsetof                   */
+#include <linux/wait.h>             /* wait queues                      */
+#include <linux/string.h>           /* strchr(), strpbrk()              */
+
+#include <linux/ctype.h>            /* isspace(), etc                   */
+#include <linux/console.h>          /* acquire_console_sem(), etc       */
+#include <linux/cpufreq.h>          /* cpufreq_get                      */
+
+#include <linux/slab.h>             /* kmalloc, kfree, etc              */
+#include <linux/vmalloc.h>          /* vmalloc, vfree, etc              */
+
+#include <linux/poll.h>             /* poll_wait                        */
+#include <linux/delay.h>            /* mdelay, udelay                   */
+
+#include <linux/sched.h>            /* suser(), capable() replacement   */
+
+/*
+ * sched.h was refactored with this commit (as part of Linux 4.11)
+ *   2017-03-03  1827adb11ad26b2290dc9fe2aaf54976b2439865
+ */
+#if defined(NV_LINUX_SCHED_SIGNAL_H_PRESENT)
+#include <linux/sched/signal.h>     /* task_lock(), task_unlock()       */
+#endif
+
+#if defined(NV_LINUX_SCHED_TASK_H_PRESENT)
+#include <linux/sched/task.h>       /* task_lock(), task_unlock()       */
+#endif
+
+/* task and signal-related items, for kernels < 4.11: */
+#include <linux/sched.h>            /* task_lock(), task_unlock()       */
+
+#include <linux/moduleparam.h>      /* module_param()                   */
+#include <asm/tlbflush.h>           /* flush_tlb(), flush_tlb_all()     */
+#include <asm/kmap_types.h>         /* page table entry lookup          */
+
+#include <linux/pci.h>              /* pci_find_class, etc              */
+#include <linux/interrupt.h>        /* tasklets, interrupt helpers      */
+#include <linux/timer.h>
+#include <linux/file.h>             /* fget(), fput()                   */
+#include <linux/rbtree.h>
+#include <linux/cpu.h>              /* CPU hotplug support              */
+
+#include <linux/pm_runtime.h>       /* pm_runtime_*                     */
+
+
+
+
+
+#include <asm/div64.h>              /* do_div()                         */
+#if defined(NV_ASM_SYSTEM_H_PRESENT)
+#include <asm/system.h>             /* cli, sli, save_flags             */
+#endif
+#include <asm/io.h>                 /* ioremap, virt_to_phys            */
+#include <asm/uaccess.h>            /* access_ok                        */
+#include <asm/page.h>               /* PAGE_OFFSET                      */
+#include <asm/pgtable.h>            /* pte bit definitions              */
+
+#include "nv-list-helpers.h"
+
+/*
+ * Use current->cred->euid, instead of calling current_euid().
+ * The latter can pull in the GPL-only debug_lockdep_rcu_enabled()
+ * symbol when CONFIG_PROVE_RCU.  That is only used for debugging.
+ *
+ * The Linux kernel relies on the assumption that only the current process
+ * is permitted to change its cred structure. Therefore, current_euid()
+ * does not require the RCU's read lock on current->cred.
+ */
+#define NV_CURRENT_EUID() (__kuid_val(current->cred->euid))
+
+#if !defined(NV_KUID_T_PRESENT)
+static inline uid_t __kuid_val(uid_t uid)
+{
+    return uid;
+}
+#endif
+
+#if defined(CONFIG_VGA_ARB)
+#include <linux/vgaarb.h>
+#endif
+
+#include <linux/pagemap.h>
+#include <linux/dma-mapping.h>
+
+#if defined(CONFIG_SWIOTLB) && defined(NVCPU_AARCH64)
+#include <linux/swiotlb.h>
+#endif
+
+#include <linux/scatterlist.h>
+#include <linux/completion.h>
+#include <linux/highmem.h>
+
+#include <linux/nodemask.h>
+
+#include <linux/workqueue.h>        /* workqueue                        */
+#include "nv-kthread-q.h"           /* kthread based queue              */
+
+#if defined(NV_LINUX_EFI_H_PRESENT)
+#include <linux/efi.h>              /* efi_enabled                      */
+#endif
+#if defined(NV_LINUX_SCREEN_INFO_H_PRESENT)
+#include <linux/screen_info.h>      /* screen_info                      */
+#else
+#include <linux/tty.h>              /* screen_info                      */
+#endif
+
+#if !defined(CONFIG_PCI)
+#warning "Attempting to build driver for a platform with no PCI support!"
+#include <asm-generic/pci-dma-compat.h>
+#endif
+
+#if defined(NV_EFI_ENABLED_PRESENT) && defined(NV_EFI_ENABLED_ARGUMENT_COUNT)
+#if (NV_EFI_ENABLED_ARGUMENT_COUNT == 1)
+#define NV_EFI_ENABLED() efi_enabled(EFI_BOOT)
+#else
+#error "NV_EFI_ENABLED_ARGUMENT_COUNT value unrecognized!"
+#endif
+#elif (defined(NV_EFI_ENABLED_PRESENT) || defined(efi_enabled))
+#define NV_EFI_ENABLED() efi_enabled
+#else
+#define NV_EFI_ENABLED() 0
+#endif
+
+#if defined(CONFIG_CRAY_XT)
+#include <cray/cray_nvidia.h>
+NV_STATUS nvos_forward_error_to_cray(struct pci_dev *, NvU32,
+        const char *, va_list);
+#endif
+
+#if defined(NVCPU_PPC64LE) && defined(CONFIG_EEH)
+#include <asm/eeh.h>
+#define NV_PCI_ERROR_RECOVERY_ENABLED() eeh_enabled()
+#define NV_PCI_ERROR_RECOVERY
+#endif
+
+#if defined(NV_ASM_SET_MEMORY_H_PRESENT)
+#include <asm/set_memory.h>
+#endif
+
+#if defined(NV_SET_MEMORY_UC_PRESENT)
+#undef NV_SET_PAGES_UC_PRESENT
+#endif
+
+#if !defined(NVCPU_FAMILY_ARM) && !defined(NVCPU_PPC64LE)
+#if !defined(NV_SET_MEMORY_UC_PRESENT) && !defined(NV_SET_PAGES_UC_PRESENT)
+#error "This driver requires the ability to change memory types!"
+#endif
+#endif
+
+/*
+ * Traditionally, CONFIG_XEN indicated that the target kernel was
+ * built exclusively for use under a Xen hypervisor, requiring
+ * modifications to or disabling of a variety of NVIDIA graphics
+ * driver code paths. As of the introduction of CONFIG_PARAVIRT
+ * and support for Xen hypervisors within the CONFIG_PARAVIRT_GUEST
+ * architecture, CONFIG_XEN merely indicates that the target
+ * kernel can run under a Xen hypervisor, but not that it will.
+ *
+ * If CONFIG_XEN and CONFIG_PARAVIRT are defined, the old Xen
+ * specific code paths are disabled. If the target kernel executes
+ * stand-alone, the NVIDIA graphics driver will work fine. If the
+ * kernels executes under a Xen (or other) hypervisor, however, the
+ * NVIDIA graphics driver has no way of knowing and is unlikely
+ * to work correctly.
+ */
+#if defined(CONFIG_XEN) && !defined(CONFIG_PARAVIRT)
+#include <asm/maddr.h>
+#include <xen/interface/memory.h>
+#define NV_XEN_SUPPORT_FULLY_VIRTUALIZED_KERNEL
+#endif
+
+#ifdef CONFIG_KDB
+#include <linux/kdb.h>
+#include <asm/kdb.h>
+#endif
+
+#if defined(CONFIG_X86_REMOTE_DEBUG)
+#include <linux/gdb.h>
+#endif
+
+#if defined(DEBUG) && defined(CONFIG_KGDB) && \
+    defined(NVCPU_FAMILY_ARM)
+#include <asm/kgdb.h>
+#endif
+
+#if (defined(NVCPU_X86) || defined(NVCPU_X86_64)) && \
+  !defined(NV_XEN_SUPPORT_FULLY_VIRTUALIZED_KERNEL)
+#define NV_ENABLE_PAT_SUPPORT
+#endif
+
+#define NV_PAT_MODE_DISABLED    0
+#define NV_PAT_MODE_KERNEL      1
+#define NV_PAT_MODE_BUILTIN     2
+
+extern int nv_pat_mode;
+
+#if defined(CONFIG_HOTPLUG_CPU)
+#define NV_ENABLE_HOTPLUG_CPU
+#include <linux/notifier.h>         /* struct notifier_block, etc       */
+#endif
+
+#if (defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE))
+#include <linux/i2c.h>
+#endif
+
+#if defined(CONFIG_ACPI)
+#include <linux/acpi.h>
+#define NV_LINUX_ACPI_EVENTS_SUPPORTED 1
+#endif
+
+#if defined(NV_LINUX_ACPI_EVENTS_SUPPORTED)
+#if (NV_ACPI_WALK_NAMESPACE_ARGUMENT_COUNT == 6)
+#define NV_ACPI_WALK_NAMESPACE(type, args...) acpi_walk_namespace(type, args)
+#elif (NV_ACPI_WALK_NAMESPACE_ARGUMENT_COUNT == 7)
+#define NV_ACPI_WALK_NAMESPACE(type, start_object, max_depth, \
+        user_function, args...) \
+    acpi_walk_namespace(type, start_object, max_depth, \
+            user_function, NULL, args)
+#else
+#error "NV_ACPI_WALK_NAMESPACE_ARGUMENT_COUNT value unrecognized!"
+#endif
+#endif
+
+#if defined(CONFIG_PREEMPT_RT) || defined(CONFIG_PREEMPT_RT_FULL)
+#define NV_CONFIG_PREEMPT_RT 1
+#endif
+
+#if defined(NVCPU_X86)
+#ifndef write_cr4
+#define write_cr4(x) __asm__ ("movl %0,%%cr4" :: "r" (x));
+#endif
+
+#ifndef read_cr4
+#define read_cr4()                                  \
+ ({                                                 \
+      unsigned int __cr4;                           \
+      __asm__ ("movl %%cr4,%0" : "=r" (__cr4));     \
+      __cr4;                                        \
+  })
+#endif
+
+#ifndef wbinvd
+#define wbinvd() __asm__ __volatile__("wbinvd" ::: "memory");
+#endif
+#endif /* defined(NVCPU_X86) */
+
+#if defined(NV_WRITE_CR4_PRESENT)
+#define NV_READ_CR4()       read_cr4()
+#define NV_WRITE_CR4(cr4)   write_cr4(cr4)
+#else
+#define NV_READ_CR4()       __read_cr4()
+#define NV_WRITE_CR4(cr4)   __write_cr4(cr4)
+#endif
+
+#ifndef get_cpu
+#define get_cpu() smp_processor_id()
+#define put_cpu()
+#endif
+
+#if !defined(unregister_hotcpu_notifier)
+#define unregister_hotcpu_notifier unregister_cpu_notifier
+#endif
+#if !defined(register_hotcpu_notifier)
+#define register_hotcpu_notifier register_cpu_notifier
+#endif
+
+#if defined(NVCPU_X86) || defined(NVCPU_X86_64)
+#if !defined(pmd_large)
+#define pmd_large(_pmd) \
+    ((pmd_val(_pmd) & (_PAGE_PSE|_PAGE_PRESENT)) == (_PAGE_PSE|_PAGE_PRESENT))
+#endif
+#endif /* defined(NVCPU_X86) || defined(NVCPU_X86_64) */
+
+#define NV_PAGE_COUNT(page) \
+  ((unsigned int)page_count(page))
+#define NV_GET_PAGE_COUNT(page_ptr) \
+  (NV_PAGE_COUNT(NV_GET_PAGE_STRUCT(page_ptr->phys_addr)))
+#define NV_GET_PAGE_FLAGS(page_ptr) \
+  (NV_GET_PAGE_STRUCT(page_ptr->phys_addr)->flags)
+
+/*
+ * Before the introduction of VM_PFNMAP, there was an VM_UNPAGED flag.
+ * Drivers which wanted to call remap_pfn_range on normal pages had to use this
+ * VM_UNPAGED flag *and* set PageReserved. With the introduction of VM_PFNMAP,
+ * that restriction went away. This is described in commit
+ *
+ *   2005-10-28 6aab341e0a28aff100a09831c5300a2994b8b986
+ *     ("mm: re-architect the VM_UNPAGED logic")
+ *
+ * , which added VM_PFNMAP and vm_normal_page. Therefore, if VM_PFNMAP is
+ * defined, then we do *not* need to mark a page as reserved, in order to
+ * call remap_pfn_range().
+ */
+#if !defined(VM_PFNMAP)
+#define NV_MAYBE_RESERVE_PAGE(ptr_ptr) \
+  SetPageReserved(NV_GET_PAGE_STRUCT(page_ptr->phys_addr))
+#define NV_MAYBE_UNRESERVE_PAGE(page_ptr) \
+  ClearPageReserved(NV_GET_PAGE_STRUCT(page_ptr->phys_addr))
+#else
+#define NV_MAYBE_RESERVE_PAGE(ptr_ptr)
+#define NV_MAYBE_UNRESERVE_PAGE(page_ptr)
+#endif /* defined (VM_PFNMAP) */
+
+#if !defined(__GFP_COMP)
+#define __GFP_COMP 0
+#endif
+
+#if !defined(DEBUG) && defined(__GFP_NOWARN)
+#define NV_GFP_KERNEL (GFP_KERNEL | __GFP_NOWARN)
+#define NV_GFP_ATOMIC (GFP_ATOMIC | __GFP_NOWARN)
+#else
+#define NV_GFP_KERNEL (GFP_KERNEL)
+#define NV_GFP_ATOMIC (GFP_ATOMIC)
+#endif
+
+#if defined(GFP_DMA32)
+/*
+ * GFP_DMA32 is similar to GFP_DMA, but instructs the Linux zone
+ * allocator to allocate memory from the first 4GB on platforms
+ * such as Linux/x86-64; the alternative is to use an IOMMU such
+ * as the one implemented with the K8 GART, if available.
+ */
+#define NV_GFP_DMA32 (NV_GFP_KERNEL | GFP_DMA32)
+#else
+#define NV_GFP_DMA32 (NV_GFP_KERNEL)
+#endif
+
+extern NvBool nvos_is_chipset_io_coherent(void);
+
+#if defined(NVCPU_X86) || defined(NVCPU_X86_64)
+#define CACHE_FLUSH()  asm volatile("wbinvd":::"memory")
+#define WRITE_COMBINE_FLUSH() asm volatile("sfence":::"memory")
+#elif defined(NVCPU_FAMILY_ARM)
+#if defined(NVCPU_ARM)
+    static inline void nv_flush_cache_cpu(void *info)
+    {
+        __cpuc_flush_kern_all();
+    }
+#define CACHE_FLUSH()            nv_flush_cache_cpu(NULL)
+#define CACHE_FLUSH_ALL()        on_each_cpu(nv_flush_cache_cpu, NULL, 1)
+#if defined(NV_OUTER_FLUSH_ALL_PRESENT)
+#define OUTER_FLUSH_ALL()               outer_flush_all()
+#endif
+#if defined(CONFIG_OUTER_CACHE)
+#define OUTER_FLUSH_RANGE(start, end)   outer_flush_range((start),(end))
+#endif
+#define WRITE_COMBINE_FLUSH()    { dsb(); outer_sync(); }
+#elif defined(NVCPU_AARCH64)
+    static inline void nv_flush_cache_cpu(void *info)
+    {
+        if (!nvos_is_chipset_io_coherent())
+        {
+#if defined(NV_FLUSH_CACHE_ALL_PRESENT)
+            flush_cache_all();
+#else
+            WARN_ONCE(0, "NVRM: kernel does not support flush_cache_all()\n");
+#endif
+        }
+    }
+#define CACHE_FLUSH()            nv_flush_cache_cpu(NULL)
+#define CACHE_FLUSH_ALL()        on_each_cpu(nv_flush_cache_cpu, NULL, 1)
+#define WRITE_COMBINE_FLUSH()    mb()
+#endif
+#elif defined(NVCPU_PPC64LE)
+#define CACHE_FLUSH()            asm volatile("sync;  \n" \
+                                              "isync; \n" ::: "memory")
+#define WRITE_COMBINE_FLUSH()    CACHE_FLUSH()
+#endif
+
+#if defined(NVCPU_FAMILY_ARM) || defined(NVCPU_PPC64LE)
+#define NV_ALLOW_WRITE_COMBINING(mt)    1
+#elif (defined(NVCPU_X86) || defined(NVCPU_X86_64))
+#if defined(NV_ENABLE_PAT_SUPPORT)
+#define NV_ALLOW_WRITE_COMBINING(mt)    \
+    ((nv_pat_mode != NV_PAT_MODE_DISABLED) && \
+     ((mt) != NV_MEMORY_TYPE_REGISTERS))
+#else
+#define NV_ALLOW_WRITE_COMBINING(mt)    0
+#endif
+#endif
+
+#if !defined(IRQF_SHARED)
+#define IRQF_SHARED SA_SHIRQ
+#endif
+
+#define NV_MAX_RECURRING_WARNING_MESSAGES 10
+
+/* various memory tracking/debugging techniques
+ * disabled for retail builds, enabled for debug builds
+ */
+
+// allow an easy way to convert all debug printfs related to memory
+// management back and forth between 'info' and 'errors'
+#if defined(NV_DBG_MEM)
+#define NV_DBG_MEMINFO NV_DBG_ERRORS
+#else
+#define NV_DBG_MEMINFO NV_DBG_INFO
+#endif
+
+#define NV_MEM_TRACKING_PAD_SIZE(size) \
+    (size) = NV_ALIGN_UP((size + sizeof(void *)), sizeof(void *))
+
+#define NV_MEM_TRACKING_HIDE_SIZE(ptr, size)            \
+    if ((ptr != NULL) && (*(ptr) != NULL))              \
+    {                                                   \
+        NvU8 *__ptr;                                    \
+        *(unsigned long *) *(ptr) = (size);             \
+        __ptr = *(ptr); __ptr += sizeof(void *);        \
+        *(ptr) = (void *) __ptr;                        \
+    }
+#define NV_MEM_TRACKING_RETRIEVE_SIZE(ptr, size)        \
+    {                                                   \
+        NvU8 *__ptr = (ptr); __ptr -= sizeof(void *);   \
+        (ptr) = (void *) __ptr;                         \
+        (size) = *(unsigned long *) (ptr);              \
+    }
+
+/* keep track of memory usage */
+#include "nv-memdbg.h"
+
+static inline void *nv_vmalloc(unsigned long size)
+{
+#if defined(NV_VMALLOC_HAS_PGPROT_T_ARG)
+    void *ptr = __vmalloc(size, GFP_KERNEL, PAGE_KERNEL);
+#else
+    void *ptr = __vmalloc(size, GFP_KERNEL);
+#endif
+    if (ptr)
+        NV_MEMDBG_ADD(ptr, size);
+    return ptr;
+}
+
+static inline void nv_vfree(void *ptr, NvU32 size)
+{
+    NV_MEMDBG_REMOVE(ptr, size);
+    vfree(ptr);
+}
+
+static inline void *nv_ioremap(NvU64 phys, NvU64 size)
+{
+    void *ptr = ioremap(phys, size);
+    if (ptr)
+        NV_MEMDBG_ADD(ptr, size);
+    return ptr;
+}
+
+static inline void *nv_ioremap_nocache(NvU64 phys, NvU64 size)
+{
+    return nv_ioremap(phys, size);
+}
+
+static inline void *nv_ioremap_cache(NvU64 phys, NvU64 size)
+{
+#if defined(NV_IOREMAP_CACHE_PRESENT)
+    void *ptr = ioremap_cache(phys, size);
+    if (ptr)
+        NV_MEMDBG_ADD(ptr, size);
+    return ptr;
+#elif defined(NVCPU_PPC64LE)
+    //
+    // ioremap_cache() has been only implemented correctly for ppc64le with
+    // commit f855b2f544d6 in April 2017 (kernel 4.12+). Internally, the kernel
+    // does provide a default implementation of ioremap_cache() that would be
+    // incorrect for our use (creating an uncached mapping) before the
+    // referenced commit, but that implementation is not exported and the
+    // NV_IOREMAP_CACHE_PRESENT conftest doesn't pick it up, and we end up in
+    // this #elif branch.
+    //
+    // At the same time, ppc64le have supported ioremap_prot() since May 2011
+    // (commit 40f1ce7fb7e8, kernel 3.0+) and that covers all kernels we
+    // support on power.
+    //
+    void *ptr = ioremap_prot(phys, size, pgprot_val(PAGE_KERNEL));
+    if (ptr)
+        NV_MEMDBG_ADD(ptr, size);
+    return ptr;
+#else
+    return nv_ioremap(phys, size);
+#endif
+}
+
+static inline void *nv_ioremap_wc(NvU64 phys, NvU64 size)
+{
+#if defined(NV_IOREMAP_WC_PRESENT)
+    void *ptr = ioremap_wc(phys, size);
+    if (ptr)
+        NV_MEMDBG_ADD(ptr, size);
+    return ptr;
+#else
+    return nv_ioremap_nocache(phys, size);
+#endif
+}
+
+static inline void nv_iounmap(void *ptr, NvU64 size)
+{
+    NV_MEMDBG_REMOVE(ptr, size);
+    iounmap(ptr);
+}
+
+static NvBool nv_numa_node_has_memory(int node_id)
+{
+    if (node_id < 0 || node_id >= MAX_NUMNODES)
+        return NV_FALSE;
+#if defined(NV_NODE_STATES_N_MEMORY_PRESENT)
+    return node_state(node_id, N_MEMORY) ? NV_TRUE : NV_FALSE;
+#else
+    return node_state(node_id, N_HIGH_MEMORY) ? NV_TRUE : NV_FALSE;
+#endif
+}
+
+#define NV_KMALLOC(ptr, size) \
+    { \
+        (ptr) = kmalloc(size, NV_GFP_KERNEL); \
+        if (ptr) \
+            NV_MEMDBG_ADD(ptr, size); \
+    }
+
+#define NV_KMALLOC_ATOMIC(ptr, size) \
+    { \
+        (ptr) = kmalloc(size, NV_GFP_ATOMIC); \
+        if (ptr) \
+            NV_MEMDBG_ADD(ptr, size); \
+    }
+
+#if defined(__GFP_RETRY_MAYFAIL)
+#define NV_GFP_NO_OOM (NV_GFP_KERNEL | __GFP_RETRY_MAYFAIL) 
+#elif defined(__GFP_NORETRY)
+#define NV_GFP_NO_OOM (NV_GFP_KERNEL | __GFP_NORETRY)
+#else
+#define NV_GFP_NO_OOM (NV_GFP_KERNEL)
+#endif
+
+#define NV_KMALLOC_NO_OOM(ptr, size) \
+    { \
+        (ptr) = kmalloc(size, NV_GFP_NO_OOM); \
+        if (ptr) \
+            NV_MEMDBG_ADD(ptr, size); \
+    }
+
+#define NV_KFREE(ptr, size) \
+    { \
+        NV_MEMDBG_REMOVE(ptr, size); \
+        kfree((void *) (ptr)); \
+    }
+
+#define NV_ALLOC_PAGES_NODE(ptr, nid, order, gfp_mask) \
+    { \
+        (ptr) = (unsigned long)page_address(alloc_pages_node(nid, gfp_mask, order)); \
+    }
+
+#define NV_GET_FREE_PAGES(ptr, order, gfp_mask)      \
+    {                                                \
+        (ptr) = __get_free_pages(gfp_mask, order);   \
+    }
+
+#define NV_FREE_PAGES(ptr, order)                    \
+    {                                                \
+        free_pages(ptr, order);                      \
+    }
+
+static inline NvUPtr nv_vmap(struct page **pages, NvU32 page_count,
+    NvBool cached)
+{
+    void *ptr;
+    pgprot_t prot = PAGE_KERNEL;
+#if defined(NVCPU_X86) || defined(NVCPU_X86_64)
+    prot = cached ? PAGE_KERNEL : PAGE_KERNEL_NOCACHE;
+#elif defined(NVCPU_FAMILY_ARM)
+    prot = cached ? PAGE_KERNEL : NV_PGPROT_UNCACHED(PAGE_KERNEL);
+#endif
+    /* All memory cached in PPC64LE; can't honor 'cached' input. */
+    ptr = vmap(pages, page_count, VM_MAP, prot);
+    if (ptr)
+        NV_MEMDBG_ADD(ptr, page_count * PAGE_SIZE);
+    return (NvUPtr)ptr;
+}
+
+static inline void nv_vunmap(NvUPtr vaddr, NvU32 page_count)
+{
+    vunmap((void *)vaddr);
+    NV_MEMDBG_REMOVE((void *)vaddr, page_count * PAGE_SIZE);
+}
+
+#if defined(NV_GET_NUM_PHYSPAGES_PRESENT)
+#define NV_NUM_PHYSPAGES                get_num_physpages()
+#else
+#define NV_NUM_PHYSPAGES                num_physpages
+#endif
+#define NV_GET_CURRENT_PROCESS()        current->tgid
+#define NV_IN_ATOMIC()                  in_atomic()
+#define NV_LOCAL_BH_DISABLE()           local_bh_disable()
+#define NV_LOCAL_BH_ENABLE()            local_bh_enable()
+#define NV_COPY_TO_USER(to, from, n)    copy_to_user(to, from, n)
+#define NV_COPY_FROM_USER(to, from, n)  copy_from_user(to, from, n)
+
+#define NV_IS_SUSER()                   capable(CAP_SYS_ADMIN)
+#define NV_PCI_DEVICE_NAME(pci_dev)     ((pci_dev)->pretty_name)
+#define NV_CLI()                        local_irq_disable()
+#define NV_SAVE_FLAGS(eflags)           local_save_flags(eflags)
+#define NV_RESTORE_FLAGS(eflags)        local_irq_restore(eflags)
+#define NV_MAY_SLEEP()                  (!irqs_disabled() && !in_interrupt() && !NV_IN_ATOMIC())
+#define NV_MODULE_PARAMETER(x)          module_param(x, int, 0)
+#define NV_MODULE_STRING_PARAMETER(x)   module_param(x, charp, 0)
+#undef  MODULE_PARM
+
+#define NV_NUM_CPUS()                   num_possible_cpus()
+
+static inline dma_addr_t nv_phys_to_dma(struct device *dev, NvU64 pa)
+{
+#if defined(NV_PHYS_TO_DMA_PRESENT)
+    return phys_to_dma(dev, pa);
+#elif defined(NV_XEN_SUPPORT_FULLY_VIRTUALIZED_KERNEL)
+    return phys_to_machine(pa);
+#else
+    return (dma_addr_t)pa;
+#endif
+}
+
+#define NV_GET_PAGE_STRUCT(phys_page) virt_to_page(__va(phys_page))
+#define NV_VMA_PGOFF(vma)             ((vma)->vm_pgoff)
+#define NV_VMA_SIZE(vma)              ((vma)->vm_end - (vma)->vm_start)
+#define NV_VMA_OFFSET(vma)            (((NvU64)(vma)->vm_pgoff) << PAGE_SHIFT)
+#define NV_VMA_PRIVATE(vma)           ((vma)->vm_private_data)
+#define NV_VMA_FILE(vma)              ((vma)->vm_file)
+
+#define NV_DEVICE_MINOR_NUMBER(x)     minor((x)->i_rdev)
+#define NV_CONTROL_DEVICE_MINOR       255
+
+#define NV_PCI_DISABLE_DEVICE(pci_dev)                           \
+    {                                                            \
+        NvU16 __cmd[2];                                          \
+        pci_read_config_word((pci_dev), PCI_COMMAND, &__cmd[0]); \
+        pci_disable_device(pci_dev);                             \
+        pci_read_config_word((pci_dev), PCI_COMMAND, &__cmd[1]); \
+        __cmd[1] |= PCI_COMMAND_MEMORY;                          \
+        pci_write_config_word((pci_dev), PCI_COMMAND,            \
+                (__cmd[1] | (__cmd[0] & PCI_COMMAND_IO)));       \
+    }
+
+#define NV_PCI_RESOURCE_START(pci_dev, bar) pci_resource_start(pci_dev, (bar))
+#define NV_PCI_RESOURCE_SIZE(pci_dev, bar)  pci_resource_len(pci_dev, (bar))
+#define NV_PCI_RESOURCE_FLAGS(pci_dev, bar) pci_resource_flags(pci_dev, (bar))
+
+#if defined(NVCPU_X86)
+#define NV_PCI_RESOURCE_VALID(pci_dev, bar)                                     \
+    ((NV_PCI_RESOURCE_START(pci_dev, bar) != 0) &&                              \
+     (NV_PCI_RESOURCE_SIZE(pci_dev, bar) != 0) &&                               \
+     (!((NV_PCI_RESOURCE_FLAGS(pci_dev, bar) & PCI_BASE_ADDRESS_MEM_TYPE_64) && \
+       ((NV_PCI_RESOURCE_START(pci_dev, bar) >> PAGE_SHIFT) > 0xfffffULL))))
+#else
+#define NV_PCI_RESOURCE_VALID(pci_dev, bar)                                     \
+    ((NV_PCI_RESOURCE_START(pci_dev, bar) != 0) &&                              \
+     (NV_PCI_RESOURCE_SIZE(pci_dev, bar) != 0))
+#endif
+
+#define NV_PCI_DOMAIN_NUMBER(pci_dev) (NvU32)pci_domain_nr(pci_dev->bus)
+#define NV_PCI_BUS_NUMBER(pci_dev)    (pci_dev)->bus->number
+#define NV_PCI_DEVFN(pci_dev)         (pci_dev)->devfn
+#define NV_PCI_SLOT_NUMBER(pci_dev)   PCI_SLOT(NV_PCI_DEVFN(pci_dev))
+
+#define NV_PCI_DEV_PUT(pci_dev)                pci_dev_put(pci_dev)
+#define NV_PCI_GET_DEVICE(vendor,device,from)  pci_get_device(vendor,device,from)
+#define NV_PCI_GET_CLASS(class,from)           pci_get_class(class,from)
+
+#if defined(CONFIG_X86_UV) && defined(NV_CONFIG_X86_UV)
+#define NV_GET_DOMAIN_BUS_AND_SLOT(domain,bus,devfn)                        \
+   ({                                                                       \
+        struct pci_dev *__dev = NULL;                                       \
+        while ((__dev = NV_PCI_GET_DEVICE(PCI_VENDOR_ID_NVIDIA,             \
+                    PCI_ANY_ID, __dev)) != NULL)                            \
+        {                                                                   \
+            if ((NV_PCI_DOMAIN_NUMBER(__dev) == domain) &&                  \
+                (NV_PCI_BUS_NUMBER(__dev) == bus) &&                        \
+                (NV_PCI_DEVFN(__dev) == devfn))                             \
+            {                                                               \
+                break;                                                      \
+            }                                                               \
+        }                                                                   \
+        if (__dev == NULL)                                                  \
+        {                                                                   \
+            while ((__dev = NV_PCI_GET_CLASS((PCI_CLASS_BRIDGE_HOST << 8),  \
+                        __dev)) != NULL)                                    \
+            {                                                               \
+                if ((NV_PCI_DOMAIN_NUMBER(__dev) == domain) &&              \
+                    (NV_PCI_BUS_NUMBER(__dev) == bus) &&                    \
+                    (NV_PCI_DEVFN(__dev) == devfn))                         \
+                {                                                           \
+                    break;                                                  \
+                }                                                           \
+            }                                                               \
+        }                                                                   \
+        if (__dev == NULL)                                                  \
+        {                                                                   \
+            while ((__dev = NV_PCI_GET_CLASS((PCI_CLASS_BRIDGE_PCI << 8),   \
+                        __dev)) != NULL)                                    \
+            {                                                               \
+                if ((NV_PCI_DOMAIN_NUMBER(__dev) == domain) &&              \
+                    (NV_PCI_BUS_NUMBER(__dev) == bus) &&                    \
+                    (NV_PCI_DEVFN(__dev) == devfn))                         \
+                {                                                           \
+                    break;                                                  \
+                }                                                           \
+            }                                                               \
+        }                                                                   \
+        if (__dev == NULL)                                                  \
+        {                                                                   \
+            while ((__dev = NV_PCI_GET_DEVICE(PCI_ANY_ID, PCI_ANY_ID,       \
+                            __dev)) != NULL)                                \
+            {                                                               \
+                if ((NV_PCI_DOMAIN_NUMBER(__dev) == domain) &&              \
+                    (NV_PCI_BUS_NUMBER(__dev) == bus) &&                    \
+                    (NV_PCI_DEVFN(__dev) == devfn))                         \
+                {                                                           \
+                    break;                                                  \
+                }                                                           \
+            }                                                               \
+        }                                                                   \
+        __dev;                                                              \
+    })
+#elif defined(NV_PCI_GET_DOMAIN_BUS_AND_SLOT_PRESENT)
+#define NV_GET_DOMAIN_BUS_AND_SLOT(domain,bus, devfn) \
+    pci_get_domain_bus_and_slot(domain, bus, devfn)
+#else
+#define NV_GET_DOMAIN_BUS_AND_SLOT(domain,bus,devfn)               \
+   ({                                                              \
+        struct pci_dev *__dev = NULL;                              \
+        while ((__dev = NV_PCI_GET_DEVICE(PCI_ANY_ID, PCI_ANY_ID,  \
+                    __dev)) != NULL)                               \
+        {                                                          \
+            if ((NV_PCI_DOMAIN_NUMBER(__dev) == domain) &&         \
+                (NV_PCI_BUS_NUMBER(__dev) == bus) &&               \
+                (NV_PCI_DEVFN(__dev) == devfn))                    \
+            {                                                      \
+                break;                                             \
+            }                                                      \
+        }                                                          \
+        __dev;                                                     \
+    })
+#endif
+
+#if defined(NV_PCI_STOP_AND_REMOVE_BUS_DEVICE_PRESENT)  // introduced in 3.4.9
+#define NV_PCI_STOP_AND_REMOVE_BUS_DEVICE(pci_dev) pci_stop_and_remove_bus_device(pci_dev)
+#elif defined(NV_PCI_REMOVE_BUS_DEVICE_PRESENT) // introduced in 2.6
+#define NV_PCI_STOP_AND_REMOVE_BUS_DEVICE(pci_dev) pci_remove_bus_device(pci_dev)
+#endif
+
+#define NV_PRINT_AT(nv_debug_level,at)                                           \
+    {                                                                            \
+        nv_printf(nv_debug_level,                                                \
+            "NVRM: VM: %s:%d: 0x%p, %d page(s), count = %d, flags = 0x%08x, "    \
+            "page_table = 0x%p\n",  __FUNCTION__, __LINE__, at,                  \
+            at->num_pages, NV_ATOMIC_READ(at->usage_count),                      \
+            at->flags, at->page_table);                                          \
+    }
+
+#define NV_PRINT_VMA(nv_debug_level,vma)                                                 \
+    {                                                                                    \
+        nv_printf(nv_debug_level,                                                        \
+            "NVRM: VM: %s:%d: 0x%lx - 0x%lx, 0x%08x bytes @ 0x%016llx, 0x%p, 0x%p\n",    \
+            __FUNCTION__, __LINE__, vma->vm_start, vma->vm_end, NV_VMA_SIZE(vma),        \
+            NV_VMA_OFFSET(vma), NV_VMA_PRIVATE(vma), NV_VMA_FILE(vma));                  \
+    }
+
+#ifndef minor
+# define minor(x) MINOR(x)
+#endif
+
+#if defined(cpu_relax)
+#define NV_CPU_RELAX() cpu_relax()
+#else
+#define NV_CPU_RELAX() barrier()
+#endif
+
+#ifndef IRQ_RETVAL
+typedef void irqreturn_t;
+#define IRQ_RETVAL(a)
+#endif
+
+#if !defined(PCI_COMMAND_SERR)
+#define PCI_COMMAND_SERR            0x100
+#endif
+#if !defined(PCI_COMMAND_INTX_DISABLE)
+#define PCI_COMMAND_INTX_DISABLE    0x400
+#endif
+
+#ifndef PCI_CAP_ID_EXP
+#define PCI_CAP_ID_EXP 0x10
+#endif
+
+/*
+ * On Linux on PPC64LE enable basic support for Linux PCI error recovery (see
+ * Documentation/PCI/pci-error-recovery.txt). Currently RM only supports error
+ * notification and data collection, not actual recovery of the device.
+ */
+#if defined(NVCPU_PPC64LE) && defined(CONFIG_EEH)
+#include <asm/eeh.h>
+#define NV_PCI_ERROR_RECOVERY
+#endif
+
+/*
+ * Early 2.6 kernels have acquire_console_sem, but from 2.6.38+ it was
+ * renamed to console_lock.
+ */
+#if defined(NV_ACQUIRE_CONSOLE_SEM_PRESENT)
+#define NV_ACQUIRE_CONSOLE_SEM() acquire_console_sem()
+#define NV_RELEASE_CONSOLE_SEM() release_console_sem()
+#elif defined(NV_CONSOLE_LOCK_PRESENT)
+#define NV_ACQUIRE_CONSOLE_SEM() console_lock()
+#define NV_RELEASE_CONSOLE_SEM() console_unlock()
+#else
+#error "console lock api unrecognized!."
+#endif
+
+/*
+ * If the host OS has page sizes larger than 4KB, we may have a security
+ * problem. Registers are typically grouped in 4KB pages, but if there are
+ * larger pages, then the smallest userspace mapping possible (e.g., a page)
+ * may give more access than intended to the user.
+ */
+#define NV_4K_PAGE_ISOLATION_REQUIRED(addr, size)                       \
+    ((PAGE_SIZE > NV_RM_PAGE_SIZE) &&                                   \
+     ((size) <= NV_RM_PAGE_SIZE) &&                                     \
+     (((addr) >> NV_RM_PAGE_SHIFT) ==                                   \
+        (((addr) + (size) - 1) >> NV_RM_PAGE_SHIFT)))
+
+/*
+ * The kernel may have a workaround for this, by providing a method to isolate
+ * a single 4K page in a given mapping.
+ */
+#if (PAGE_SIZE > NV_RM_PAGE_SIZE) && defined(NVCPU_PPC64LE) && defined(NV_PAGE_4K_PFN)
+    #define NV_4K_PAGE_ISOLATION_PRESENT
+    #define NV_4K_PAGE_ISOLATION_MMAP_ADDR(addr)                        \
+        ((NvP64)((void*)(((addr) >> NV_RM_PAGE_SHIFT) << PAGE_SHIFT)))
+    #define NV_4K_PAGE_ISOLATION_MMAP_LEN(size)     PAGE_SIZE
+    #define NV_4K_PAGE_ISOLATION_ACCESS_START(addr)                     \
+        ((NvP64)((void*)((addr) & ~NV_RM_PAGE_MASK)))
+    #define NV_4K_PAGE_ISOLATION_ACCESS_LEN(addr, size)                 \
+        ((((addr) & NV_RM_PAGE_MASK) + size + NV_RM_PAGE_MASK) &        \
+         ~NV_RM_PAGE_MASK)
+    #define NV_PROT_4K_PAGE_ISOLATION NV_PAGE_4K_PFN
+#endif
+
+static inline int nv_remap_page_range(struct vm_area_struct *vma,
+    unsigned long virt_addr, NvU64 phys_addr, NvU64 size, pgprot_t prot)
+{
+    int ret = -1;
+
+#if defined(NV_4K_PAGE_ISOLATION_PRESENT) && defined(NV_PROT_4K_PAGE_ISOLATION)
+    if ((size == PAGE_SIZE) &&
+        ((pgprot_val(prot) & NV_PROT_4K_PAGE_ISOLATION) != 0))
+    {
+        /*
+         * remap_4k_pfn() hardcodes the length to a single OS page, and checks
+         * whether applying the page isolation workaround will cause PTE
+         * corruption (in which case it will fail, and this is an unsupported
+         * configuration).
+         */
+#if defined(NV_HASH__REMAP_4K_PFN_PRESENT)
+        ret = hash__remap_4k_pfn(vma, virt_addr, (phys_addr >> PAGE_SHIFT), prot);
+#else
+        ret = remap_4k_pfn(vma, virt_addr, (phys_addr >> PAGE_SHIFT), prot);
+#endif
+    }
+    else
+#endif
+    {
+        ret = remap_pfn_range(vma, virt_addr, (phys_addr >> PAGE_SHIFT), size,
+            prot);
+    }
+
+    return ret;
+}
+
+static inline int nv_io_remap_page_range(struct vm_area_struct *vma,
+    NvU64 phys_addr, NvU64 size, NvU32 extra_prot)
+{
+    int ret = -1;
+#if !defined(NV_XEN_SUPPORT_FULLY_VIRTUALIZED_KERNEL)
+    ret = nv_remap_page_range(vma, vma->vm_start, phys_addr, size,
+        __pgprot(pgprot_val(vma->vm_page_prot) | extra_prot));
+#else
+    ret = io_remap_pfn_range(vma, vma->vm_start, (phys_addr >> PAGE_SHIFT),
+        size, __pgprot(pgprot_val(vma->vm_page_prot) | extra_prot));
+#endif
+    return ret;
+}
+
+static inline vm_fault_t nv_insert_pfn(struct vm_area_struct *vma,
+    NvU64 virt_addr, NvU64 pfn, NvU32 extra_prot)
+{
+    /*
+     * vm_insert_pfn{,_prot} replaced with vmf_insert_pfn{,_prot} in Linux 4.20
+     */
+#if defined(NV_VMF_INSERT_PFN_PROT_PRESENT)
+    return vmf_insert_pfn_prot(vma, virt_addr, pfn,
+             __pgprot(pgprot_val(vma->vm_page_prot) | extra_prot));
+#else
+    int ret = -EINVAL;
+    /*
+     * Only PPC64LE (NV_4K_PAGE_ISOLATION_PRESENT) requires extra_prot to be
+     * used when remapping.
+     *
+     * vm_insert_pfn_prot() was added in Linux 4.4, whereas POWER9 support
+     * was added in Linux 4.8.
+     *
+     * Rather than tampering with the vma to make use of extra_prot with
+     * vm_insert_pfn() on older kernels, for now, just fail in this case, as
+     * it's not expected to be used currently.
+     */
+#if defined(NV_VM_INSERT_PFN_PROT_PRESENT)
+    ret = vm_insert_pfn_prot(vma, virt_addr, pfn,
+        __pgprot(pgprot_val(vma->vm_page_prot) | extra_prot));
+#elif !defined(NV_4K_PAGE_ISOLATION_PRESENT)
+    ret = vm_insert_pfn(vma, virt_addr, pfn);
+#endif
+    switch (ret)
+    {
+        case 0:
+        case -EBUSY:
+            /*
+             * EBUSY indicates that another thread already handled
+             * the faulted range.
+             */
+            return VM_FAULT_NOPAGE;
+        case -ENOMEM:
+            return VM_FAULT_OOM;
+        default:
+            break;
+    }
+#endif /* defined(NV_VM_INSERT_PFN_PROT_PRESENT) */
+    return VM_FAULT_SIGBUS;
+}
+
+
+#define NV_PAGE_MASK    (NvU64)(long)PAGE_MASK
+
+extern void *nvidia_stack_t_cache;
+
+/*
+ * On Linux, when a kmem cache is created, a new sysfs entry is created
+ * for the same unless it's merged with an existing cache. Upstream Linux
+ * kernel commit 3b7b314053d021601940c50b07f5f1423ae67e21 (version 4.12+)
+ * made cache destruction asynchronous which creates a race between cache
+ * destroy and create. A new cache created with attributes as
+ * a previous cache, which is scheduled for destruction, can try to create
+ * a sysfs entry with the same conflicting name. Upstream Linux kernel
+ * commit d50d82faa0c964e31f7a946ba8aba7c715ca7ab0 (4.18) fixes this issue
+ * by cleaning up sysfs entry within slab_mutex, so the entry is deleted
+ * before a cache with the same attributes could be created.
+ *
+ * To workaround this kernel issue we take two steps:
+ * - Create unmergeable caches: a kmem_cache with a constructor is
+ *   unmergeable. So, we define an empty contructor for the same.
+ *   We need to create unmergeable caches to control all kmem destory
+ *   calls so we can flush.
+ * - Issue flush_scheduled_work() after kmem_cache_destroy() to make cache
+ *   destruction immediate and avoid race between destroy and create as
+ *   described above.
+ */
+#if defined(NV_KMEM_CACHE_HAS_KOBJ_REMOVE_WORK) && !defined(NV_SYSFS_SLAB_UNLINK_PRESENT)
+static inline void nv_kmem_ctor_dummy(void *arg)
+{
+    (void)arg;
+}
+#define NV_KMEM_CACHE_DESTROY_FLUSH flush_scheduled_work
+#else
+#define nv_kmem_ctor_dummy NULL
+#define NV_KMEM_CACHE_DESTROY_FLUSH()
+#endif
+
+#define NV_KMEM_CACHE_CREATE(name, type)    \
+    kmem_cache_create(name, sizeof(type), 0, 0, nv_kmem_ctor_dummy)
+
+/* The NULL pointer check is required for kernels older than 4.3 */
+#define NV_KMEM_CACHE_DESTROY(kmem_cache)   \
+    if (kmem_cache != NULL)                 \
+    {                                       \
+        kmem_cache_destroy(kmem_cache);     \
+        NV_KMEM_CACHE_DESTROY_FLUSH();      \
+    }
+
+#define NV_KMEM_CACHE_ALLOC(kmem_cache)     \
+    kmem_cache_alloc(kmem_cache, GFP_KERNEL)
+#define NV_KMEM_CACHE_FREE(ptr, kmem_cache) \
+    kmem_cache_free(kmem_cache, ptr)
+
+static inline void *nv_kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags)
+{
+#if defined(NV_KMEM_CACHE_HAS_KOBJ_REMOVE_WORK) && !defined(NV_SYSFS_SLAB_UNLINK_PRESENT)
+    /*
+     * We cannot call kmem_cache_zalloc directly as it adds the __GFP_ZERO
+     * flag. This flag together with the presence of a slab constructor is
+     * flagged as a potential bug by the Linux kernel since it is the role
+     * of a constructor to fill an allocated object with the desired
+     * pattern. In our case, we specified a (dummy) constructor as a
+     * workaround for a bug and not to zero-initialize objects. So, we take
+     * the pain here to memset allocated object ourselves.
+     */
+    void *object = kmem_cache_alloc(k, flags);
+    if (object)
+        memset(object, 0, kmem_cache_size(k));
+    return object;
+#else
+    return kmem_cache_zalloc(k, flags);
+#endif
+}
+
+static inline int nv_kmem_cache_alloc_stack(nvidia_stack_t **stack)
+{
+    nvidia_stack_t *sp = NULL;
+#if defined(NVCPU_X86) || defined(NVCPU_X86_64)
+    sp = NV_KMEM_CACHE_ALLOC(nvidia_stack_t_cache);
+    if (sp == NULL)
+        return -ENOMEM;
+    sp->size = sizeof(sp->stack);
+    sp->top = sp->stack + sp->size;
+#endif
+    *stack = sp;
+    return 0;
+}
+
+static inline void nv_kmem_cache_free_stack(nvidia_stack_t *stack)
+{
+#if defined(NVCPU_X86) || defined(NVCPU_X86_64)
+    if (stack != NULL)
+    {
+        NV_KMEM_CACHE_FREE(stack, nvidia_stack_t_cache);
+    }
+#endif
+}
+
+#if defined(NVCPU_X86) || defined(NVCPU_X86_64)
+/*
+ * RAM is cached on Linux by default, we can assume there's
+ * nothing to be done here. This is not the case for the
+ * other memory spaces: we will have made an attempt to add
+ * a WC MTRR for the frame buffer.
+ *
+ * If a WC MTRR is present, we can't satisfy the WB mapping
+ * attempt here, since the achievable effective memory
+ * types in that case are WC and UC, if not it's typically
+ * UC (MTRRdefType is UC); we could only satisfy WB mapping
+ * requests with a WB MTRR.
+ */
+#define NV_ALLOW_CACHING(mt)            ((mt) == NV_MEMORY_TYPE_SYSTEM)
+#else
+#define NV_ALLOW_CACHING(mt)            ((mt) != NV_MEMORY_TYPE_REGISTERS)
+#endif
+
+typedef struct nvidia_pte_s {
+    NvU64           phys_addr;
+    unsigned long   virt_addr;
+    NvU64           dma_addr;
+#ifdef CONFIG_XEN
+    unsigned int    guest_pfn;
+#endif
+    unsigned int    page_count;
+} nvidia_pte_t;
+
+typedef struct nv_alloc_s {
+    struct nv_alloc_s *next;
+    struct device     *dev;
+    atomic_t       usage_count;
+    unsigned int   flags;
+    unsigned int   num_pages;
+    unsigned int   order;
+    unsigned int   size;
+    nvidia_pte_t **page_table;          /* list of physical pages allocated */
+    unsigned int   pid;
+    struct page  **user_pages;
+    NvU64         guest_id;             /* id of guest VM */
+} nv_alloc_t;
+
+#define NV_ALLOC_TYPE_PCI               (1<<0)
+#define NV_ALLOC_TYPE_CONTIG            (1<<2)
+#define NV_ALLOC_TYPE_GUEST             (1<<3)
+#define NV_ALLOC_TYPE_ZEROED            (1<<4)
+#define NV_ALLOC_TYPE_ALIASED           (1<<5)
+#define NV_ALLOC_TYPE_USER              (1<<6)
+#define NV_ALLOC_TYPE_NODE0             (1<<7)
+#define NV_ALLOC_TYPE_PEER_IO           (1<<8)
+#define NV_ALLOC_TYPE_PHYSICAL          (1<<9)
+
+#define NV_ALLOC_MAPPING_SHIFT      16
+#define NV_ALLOC_MAPPING(flags)     (((flags)>>NV_ALLOC_MAPPING_SHIFT)&0xff)
+#define NV_ALLOC_ENC_MAPPING(flags) ((flags)<<NV_ALLOC_MAPPING_SHIFT)
+
+#define NV_ALLOC_MAPPING_CACHED(flags)        (NV_ALLOC_MAPPING(flags) == NV_MEMORY_CACHED)
+#define NV_ALLOC_MAPPING_UNCACHED(flags)      (NV_ALLOC_MAPPING(flags) == NV_MEMORY_UNCACHED)
+#define NV_ALLOC_MAPPING_WRITECOMBINED(flags) (NV_ALLOC_MAPPING(flags) == NV_MEMORY_WRITECOMBINED)
+
+#define NV_ALLOC_MAPPING_CONTIG(flags)            ((flags) & NV_ALLOC_TYPE_CONTIG)
+#define NV_ALLOC_MAPPING_GUEST(flags)             ((flags) & NV_ALLOC_TYPE_GUEST)
+#define NV_ALLOC_MAPPING_ALIASED(flags)           ((flags) & NV_ALLOC_TYPE_ALIASED)
+#define NV_ALLOC_MAPPING_USER(flags)              ((flags) & NV_ALLOC_TYPE_USER)
+#define NV_ALLOC_MAPPING_PEER_IO(flags)           ((flags) & NV_ALLOC_TYPE_PEER_IO)
+#define NV_ALLOC_MAPPING_PHYSICAL(flags)          ((flags) & NV_ALLOC_TYPE_PHYSICAL)
+
+static inline NvU32 nv_alloc_init_flags(int cached, int contiguous, int zeroed)
+{
+    NvU32 flags = NV_ALLOC_ENC_MAPPING(cached);
+    flags |= NV_ALLOC_TYPE_PCI;
+    if (contiguous)
+        flags |= NV_ALLOC_TYPE_CONTIG;
+    if (zeroed)
+        flags |= NV_ALLOC_TYPE_ZEROED;
+#if defined(NVCPU_FAMILY_ARM)
+    if (!NV_ALLOC_MAPPING_CACHED(flags))
+        flags |= NV_ALLOC_TYPE_ALIASED;
+#endif
+    return flags;
+}
+
+/**
+ * nv_is_dma_direct - return true if direct_dma is enabled
+ *
+ * Starting with the 5.0 kernel, SWIOTLB is merged into
+ * direct_dma, so systems without an IOMMU use direct_dma.  We
+ * need to know if this is the case, so that we can use a
+ * different check for SWIOTLB enablement.
+ */
+static inline NvBool nv_is_dma_direct(struct device *dev)
+{
+    NvBool is_direct = NV_FALSE;
+
+#if defined(NV_DMA_IS_DIRECT_PRESENT)
+    if (dma_is_direct(get_dma_ops(dev)))
+        is_direct = NV_TRUE;
+#endif
+
+    return is_direct;
+}
+
+/**
+ * nv_dma_maps_swiotlb - return NV_TRUE if swiotlb is enabled
+ *
+ * SWIOTLB creates bounce buffers for the DMA mapping layer to
+ * use if a driver asks the kernel to map a DMA buffer that is
+ * outside of the device's addressable range.  The driver does
+ * not function correctly if bounce buffers are enabled for the
+ * device.  So if SWIOTLB is enabled, we should avoid making
+ * mapping calls.
+ */
+static inline NvBool
+nv_dma_maps_swiotlb(struct device *dev)
+{
+    NvBool swiotlb_in_use = NV_FALSE;
+#if defined(CONFIG_SWIOTLB)
+  #if defined(NV_DMA_OPS_PRESENT) || defined(NV_GET_DMA_OPS_PRESENT) || \
+      defined(NV_SWIOTLB_DMA_OPS_PRESENT)
+    /*
+     * We only use the 'dma_ops' symbol on older x86_64 kernels; later kernels,
+     * including those for other architectures, have converged on the
+     * get_dma_ops() interface.
+     */
+    #if defined(NV_GET_DMA_OPS_PRESENT)
+    /*
+     * The __attribute__ ((unused)) is necessary because in at least one
+     * case, *none* of the preprocessor branches below are taken, and
+     * so the ops variable ends up never being referred to at all. This can
+     * happen with the (NV_IS_EXPORT_SYMBOL_PRESENT_swiotlb_map_sg_attrs == 1)
+     * case.
+     */
+    const struct dma_map_ops *ops __attribute__ ((unused)) = get_dma_ops(dev);
+    #else
+    const struct dma_mapping_ops *ops __attribute__ ((unused)) = dma_ops;
+    #endif
+
+    /*
+     * The switch from dma_mapping_ops -> dma_map_ops coincided with the
+     * switch from swiotlb_map_sg -> swiotlb_map_sg_attrs.
+     */
+      #if defined(NVCPU_AARCH64) && \
+          defined(NV_NONCOHERENT_SWIOTLB_DMA_OPS_PRESENT)
+    /* AArch64 exports these symbols directly */
+    swiotlb_in_use = ((ops == &noncoherent_swiotlb_dma_ops) ||
+                      (ops == &coherent_swiotlb_dma_ops));
+      #elif NV_IS_EXPORT_SYMBOL_PRESENT_swiotlb_map_sg_attrs != 0
+    swiotlb_in_use = (ops->map_sg == swiotlb_map_sg_attrs);
+      #elif NV_IS_EXPORT_SYMBOL_PRESENT_swiotlb_dma_ops != 0
+    swiotlb_in_use = (ops == &swiotlb_dma_ops);
+      #endif
+      /*
+       * The "else" case that is not shown
+       * (for NV_IS_EXPORT_SYMBOL_PRESENT_swiotlb_map_sg_attrs == 0 ||
+       * NV_IS_EXPORT_SYMBOL_PRESENT_swiotlb_dma_ops == 0) does
+       * nothing, and ends up dropping us out to the last line of this function,
+       * effectively returning false. The nearly-human-readable version of that
+       * case is "struct swiotlb_dma_ops is present (NV_SWIOTLB_DMA_OPS_PRESENT
+       * is defined) but neither swiotlb_map_sg_attrs nor swiotlb_dma_ops is
+       * present".
+       *
+       * That can happen on kernels that fall within below range:
+       *
+       * 2017-12-24  4bd89ed39b2ab8dc4ac4b6c59b07d420b0213bec
+       *     ("swiotlb: remove various exports")
+       * 2018-06-28  210d0797c97d0e8f3b1a932a0dc143f4c57008a3
+       *     ("swiotlb: export swiotlb_dma_ops")
+       *
+       * Related to this: Between above two commits, this driver has no way of
+       * detecting whether or not the SWIOTLB is in use. Furthermore, the
+       * driver cannot support DMA remapping. That leads to the following
+       * point: "swiotlb=force" is not supported for kernels falling in above
+       * range.
+       *
+       * The other "else" case that is not shown:
+       * Starting with the 5.0 kernel, swiotlb is integrated into dma_direct,
+       * which is used when there's no IOMMU.  In these kernels, ops == NULL,
+       * swiotlb_dma_ops no longer exists, and we do not support swiotlb=force
+       * (doing so would require detecting when swiotlb=force is enabled and
+       * then returning NV_TRUE even when dma_direct is in use).  So for now,
+       * we just return NV_FALSE and in nv_compute_gfp_mask() we check for
+       * whether swiotlb could possibly be used (outside of swiotlb=force).
+       */
+  #endif
+#endif
+
+    return swiotlb_in_use;
+}
+
+/*
+ * TODO: Bug 1522381 will allow us to move these mapping relationships into
+ *       common code.
+ */
+
+/*
+ * Bug 1606851: the Linux kernel scatterlist code doesn't work for regions
+ * greater than or equal to 4GB, due to regular use of unsigned int
+ * throughout. So we need to split our mappings into 4GB-minus-1-page-or-less
+ * chunks and manage them separately.
+ */
+typedef struct nv_dma_submap_s {
+    NvU32 page_count;
+    NvU32 sg_map_count;
+    struct sg_table sgt;
+} nv_dma_submap_t;
+
+typedef struct nv_dma_map_s {
+    struct page **pages;
+    NvU64 page_count;
+    NvBool contiguous;
+
+    union
+    {
+        struct
+        {
+            NvU32 submap_count;
+            nv_dma_submap_t *submaps;
+        } discontig;
+
+        struct
+        {
+            NvU64 dma_addr;
+        } contig;
+    } mapping;
+
+    struct device *dev;
+} nv_dma_map_t;
+
+#define NV_FOR_EACH_DMA_SUBMAP(dm, sm, i)                                     \
+    for (i = 0, sm = &dm->mapping.discontig.submaps[0];                       \
+         i < dm->mapping.discontig.submap_count;                              \
+         i++, sm = &dm->mapping.discontig.submaps[i])
+
+#define NV_DMA_SUBMAP_MAX_PAGES           ((NvU32)(NV_U32_MAX >> PAGE_SHIFT))
+#define NV_DMA_SUBMAP_IDX_TO_PAGE_IDX(s)  (s * NV_DMA_SUBMAP_MAX_PAGES)
+
+/*
+ * DO NOT use sg_alloc_table_from_pages on Xen Server, even if it's available.
+ * This will glom multiple pages into a single sg element, which
+ * xen_swiotlb_map_sg_attrs may try to route to the SWIOTLB. We must only use
+ * single-page sg elements on Xen Server.
+ */
+#if defined(NV_SG_ALLOC_TABLE_FROM_PAGES_PRESENT) && \
+    !defined(NV_DOM0_KERNEL_PRESENT)
+    #define NV_ALLOC_DMA_SUBMAP_SCATTERLIST(dm, sm, i)                        \
+        ((sg_alloc_table_from_pages(&sm->sgt,                                 \
+            &dm->pages[NV_DMA_SUBMAP_IDX_TO_PAGE_IDX(i)],                     \
+            sm->page_count, 0,                                                \
+            sm->page_count * PAGE_SIZE, NV_GFP_KERNEL) == 0) ? NV_OK :        \
+                NV_ERR_OPERATING_SYSTEM)
+#else
+    #define NV_ALLOC_DMA_SUBMAP_SCATTERLIST(dm, sm, i)                \
+        ((sg_alloc_table(&sm->sgt, sm->page_count, NV_GFP_KERNEL)) == \
+            0 ? NV_OK : NV_ERR_OPERATING_SYSTEM)
+#endif
+
+typedef struct nv_ibmnpu_info nv_ibmnpu_info_t;
+
+typedef struct nv_work_s {
+    struct work_struct task;
+    void *data;
+} nv_work_t;
+
+#define NV_MAX_REGISTRY_KEYS_LENGTH   512
+
+typedef enum
+{
+    NV_DEV_STACK_TIMER,
+    NV_DEV_STACK_ISR,
+    NV_DEV_STACK_ISR_BH,
+    NV_DEV_STACK_ISR_BH_UNLOCKED,
+    NV_DEV_STACK_GPU_WAKEUP,
+    NV_DEV_STACK_COUNT
+} nvidia_linux_dev_stack_t;
+
+/* Linux version of the opaque type used for os_queue_work_item() */
+struct os_work_queue {
+    nv_kthread_q_t nvk;
+};
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * To report error in msi/msix when unhandled count reaches a threshold
+ */
+
+typedef struct nv_irq_count_info_s
+{
+    int    irq;
+    NvU64  unhandled;
+    NvU64  total;
+    NvU64  last_unhandled;
+} nv_irq_count_info_t;
+
+/* linux-specific version of old nv_state_t */
+/* this is a general os-specific state structure. the first element *must* be
+   the general state structure, for the generic unix-based code */
+typedef struct nv_linux_state_s {
+    nv_state_t nv_state;
+
+    atomic_t usage_count;
+    NvU32    suspend_count;
+
+    struct device  *dev;
+    struct pci_dev *pci_dev;
+
+    /* IBM-NPU info associated with this GPU */
+    nv_ibmnpu_info_t *npu;
+
+    nvidia_stack_t *sp[NV_DEV_STACK_COUNT];
+
+    char registry_keys[NV_MAX_REGISTRY_KEYS_LENGTH];
+
+    nv_work_t work;
+
+    /* get a timer callback every second */
+    struct nv_timer rc_timer;
+
+    /* lock for linux-specific data, not used by core rm */
+    struct semaphore ldata_lock;
+
+    /* proc directory information */
+    struct proc_dir_entry *proc_dir;
+
+    NvU32 minor_num;
+    struct nv_linux_state_s *next;
+
+    /* DRM private information */
+    struct drm_device *drm;
+
+    /* kthread based bottom half servicing queue and elements */
+    nv_kthread_q_t bottom_half_q;
+    nv_kthread_q_item_t bottom_half_q_item;
+
+    /* Lock for unlocked bottom half protecting common allocated stack */
+    void *isr_bh_unlocked_mutex;
+
+    NvBool tce_bypass_enabled;
+
+    NvU32 num_intr;
+
+    /* Lock serializing ISRs for different MSI-X vectors */
+    nv_spinlock_t msix_isr_lock;
+
+    /* Lock serializing bottom halves for different MSI-X vectors */
+    void *msix_bh_mutex;
+
+    struct msix_entry *msix_entries;
+
+    atomic_t msix_ref_cnt;
+
+    NvU64 numa_memblock_size;
+
+    struct {
+        struct backlight_device *dev;
+        NvU32 displayId;
+    } backlight;
+
+    /*
+     * file handle for pci sysfs config file (/sys/bus/pci/devices/.../config)
+     * which will be opened during device probe
+     */
+    struct file *sysfs_config_file;
+
+    /* Per-GPU queue */
+    struct os_work_queue queue;
+
+    /* GPU user mapping revocation/remapping (only for non-CTL device) */
+    struct semaphore mmap_lock; /* Protects all fields in this category */
+    struct list_head open_files;
+    NvBool all_mappings_revoked;
+    NvBool safe_to_mmap;
+    NvBool gpu_wakeup_callback_needed;
+
+    /* Per-device notifier block for ACPI events */
+    struct notifier_block acpi_nb;
+
+    NvBool is_forced_shutdown;
+
+
+
+
+
+
+    /* Lock serializing ISRs for different SOC vectors */
+    nv_spinlock_t soc_isr_lock;
+
+    struct nv_timer snapshot_timer;
+    nv_spinlock_t snapshot_timer_lock;
+    void (*snapshot_callback)(void *context);
+
+    /* count for unhandled, total and timestamp of irq */
+    nv_irq_count_info_t *irq_count;
+
+    /* Max number of irq triggered and are getting tracked */
+    NvU16 current_num_irq_tracked;
+} nv_linux_state_t;
+
+extern nv_linux_state_t *nv_linux_devices;
+
+/*
+ * Macros to protect operations on nv_linux_devices list
+ * Lock acquisition order while using the nv_linux_devices list
+ * 1. LOCK_NV_LINUX_DEVICES()
+ * 2. Traverse the list
+ *    If the list is traversed to search for an element say nvl,
+ *    acquire the nvl->ldata_lock before step 3
+ * 3. UNLOCK_NV_LINUX_DEVICES()
+ * 4. Release nvl->ldata_lock after any read/write access to the
+ *    nvl element is complete
+ */
+extern struct semaphore nv_linux_devices_lock;
+#define LOCK_NV_LINUX_DEVICES()     down(&nv_linux_devices_lock)
+#define UNLOCK_NV_LINUX_DEVICES()   up(&nv_linux_devices_lock)
+
+/*
+ * Macros to synchronize system power management transitions,
+ * and to protect the global system PM state.  The procfs power
+ * management interface acquires this lock in write mode for
+ * the duration of the sleep operation, any other paths accessing
+ * device state must acquire the lock in read mode.
+ */
+extern struct rw_semaphore nv_system_pm_lock;
+
+/*
+ * Approximate what down_read_interruptible() would accomplish
+ * it were available.  This is currently only needed to catch
+ * the fake signals sent from the freezer in the kernel's system
+ * suspend/hibernate paths.
+ */
+static inline int nv_read_lock_system_pm_lock_interruptible(void)
+{
+    while (!down_read_trylock(&nv_system_pm_lock))
+    {
+        if (signal_pending(current))
+            return -EINTR;
+        cond_resched();
+    }
+    return 0;
+}
+
+#define NV_READ_LOCK_SYSTEM_PM_LOCK()   down_read(&nv_system_pm_lock)
+#define NV_READ_LOCK_SYSTEM_PM_LOCK_INTERRUPTIBLE() \
+    nv_read_lock_system_pm_lock_interruptible()
+#define NV_READ_UNLOCK_SYSTEM_PM_LOCK() up_read(&nv_system_pm_lock)
+
+#define NV_WRITE_LOCK_SYSTEM_PM_LOCK()   down_write(&nv_system_pm_lock)
+#define NV_WRITE_UNLOCK_SYSTEM_PM_LOCK() up_write(&nv_system_pm_lock)
+
+extern NvBool nv_ats_supported;
+
+#if defined(NV_LINUX_ACPI_EVENTS_SUPPORTED)
+/*
+ * acpi data storage structure
+ *
+ * This structure retains the pointer to the device,
+ * and any other baggage we want to carry along
+ *
+ */
+#define NV_MAXNUM_DISPLAY_DEVICES 8
+
+typedef struct
+{
+    acpi_handle dev_handle;
+    int dev_id;
+} nv_video_t;
+
+typedef struct
+{
+    nvidia_stack_t *sp;
+    struct acpi_device *device;
+
+    nv_video_t pNvVideo[NV_MAXNUM_DISPLAY_DEVICES];
+
+    int notify_handler_installed;
+    int default_display_mask;
+} nv_acpi_t;
+
+#endif
+
+/*
+ * file-private data
+ * hide a pointer to our data structures in a file-private ptr
+ * there are times we need to grab this data back from the file
+ * data structure..
+ */
+
+typedef struct nvidia_event
+{
+    struct nvidia_event *next;
+    nv_event_t event;
+} nvidia_event_t;
+
+typedef enum
+{
+    NV_FOPS_STACK_INDEX_MMAP,
+    NV_FOPS_STACK_INDEX_IOCTL,
+    NV_FOPS_STACK_INDEX_PROCFS,
+    NV_FOPS_STACK_INDEX_COUNT
+} nvidia_entry_point_index_t;
+
+typedef struct
+{
+    nvidia_stack_t *sp;
+    nvidia_stack_t *fops_sp[NV_FOPS_STACK_INDEX_COUNT];
+    struct semaphore fops_sp_lock[NV_FOPS_STACK_INDEX_COUNT];
+    nv_alloc_t *free_list;
+    void *nvptr;
+    void *proc_data;
+    void *data;
+    nvidia_event_t *event_head, *event_tail;
+    int event_pending;
+    nv_spinlock_t fp_lock;
+    wait_queue_head_t waitqueue;
+    nv_kthread_q_item_t deferred_close_q_item;
+    off_t off;
+    NvU32 minor_num;
+    NvHandle hExportedRmObject[NV_MAX_RM_EXPORTED_OBJECTS];
+    NvU32 numExportedRmObjects;
+    NvU32 deviceInstance;
+    NvU32 *attached_gpus;
+    size_t num_attached_gpus;
+    nv_alloc_mapping_context_t mmap_context;
+    struct address_space mapping;
+
+    struct list_head entry;
+} nv_file_private_t;
+
+#define NV_SET_FILE_PRIVATE(filep,data) ((filep)->private_data = (data))
+#define NV_GET_FILE_PRIVATE(filep) ((nv_file_private_t *)(filep)->private_data)
+
+/* for the card devices */
+#define NV_GET_NVL_FROM_FILEP(filep)    (NV_GET_FILE_PRIVATE(filep)->nvptr)
+#define NV_GET_NVL_FROM_NV_STATE(nv)    ((nv_linux_state_t *)nv->os_state)
+
+#define NV_STATE_PTR(nvl)   &(((nv_linux_state_t *)(nvl))->nv_state)
+
+
+#define NV_ATOMIC_READ(data)            atomic_read(&(data))
+#define NV_ATOMIC_SET(data,val)         atomic_set(&(data), (val))
+#define NV_ATOMIC_INC(data)             atomic_inc(&(data))
+#define NV_ATOMIC_DEC(data)             atomic_dec(&(data))
+#define NV_ATOMIC_DEC_AND_TEST(data)    atomic_dec_and_test(&(data))
+
+
+#if defined(CONFIG_PCI_IOV)
+#define NV_PCI_SRIOV_SUPPORT
+#endif /* CONFIG_PCI_IOV */
+
+
+#define NV_PCIE_CFG_MAX_OFFSET 0x1000
+
+#include "nv-proto.h"
+
+/*
+ * Check if GPU is present on the bus by checking flag
+ * NV_FLAG_IN_SURPRISE_REMOVAL(set when eGPU is removed from TB3).
+ */
+static inline NV_STATUS nv_check_gpu_state(nv_state_t *nv)
+{
+#if !defined(NVCPU_PPC64LE)
+    if (NV_IS_DEVICE_IN_SURPRISE_REMOVAL(nv))
+    {
+        return NV_ERR_GPU_IS_LOST;
+    }
+#endif
+
+    return NV_OK;
+}
+
+extern NvU32 NVreg_EnableUserNUMAManagement;
+extern NvU32 NVreg_RegisterPCIDriver;
+
+extern nv_pci_info_t nv_assign_gpu_pci_info[NV_MAX_DEVICES];
+extern NvU32 nv_assign_gpu_count;
+extern NvU32 num_probed_nv_devices;
+extern NvU32 num_nv_devices;
+
+#define NV_IS_ASSIGN_GPU_PCI_INFO_SPECIFIED()     \
+    (!((nv_assign_gpu_pci_info[0].domain == 0) && \
+       (nv_assign_gpu_pci_info[0].bus == 0) &&    \
+       (nv_assign_gpu_pci_info[0].slot == 0)))
+
+#if defined(NV_FILE_HAS_INODE)
+#define NV_FILE_INODE(file) (file)->f_inode
+#else
+#define NV_FILE_INODE(file) (file)->f_dentry->d_inode
+#endif
+
+#if defined(NV_DOM0_KERNEL_PRESENT) || defined(NV_VGPU_KVM_BUILD)
+#define NV_VGX_HYPER
+#if defined(NV_XEN_IOEMU_INJECT_MSI)
+#include <xen/ioemu.h>
+#endif
+#endif
+
+static inline NvU64 nv_node_end_pfn(int nid)
+{
+#if defined(NV_NODE_END_PFN_PRESENT)
+    return node_end_pfn(nid);
+#else
+    return NODE_DATA(nid)->node_start_pfn + node_spanned_pages(nid);
+#endif
+}
+
+static inline NvU64 nv_pci_bus_address(nv_linux_state_t *nvl, NvU8 bar_index)
+{
+    NvU64 bus_addr = 0;
+#if defined(NV_PCI_BUS_ADDRESS_PRESENT)
+    bus_addr = pci_bus_address(nvl->pci_dev, bar_index);
+#elif defined(CONFIG_PCI)
+    struct pci_bus_region region;
+
+    pcibios_resource_to_bus(nvl->pci_dev, &region,
+                            &nvl->pci_dev->resource[bar_index]);
+    bus_addr = region.start;
+#endif
+    return bus_addr;
+}
+
+/*
+ * Decrements the usage count of the allocation, and moves the allocation to
+ * the given nvfp's free list if the usage count drops to zero.
+ *
+ * Returns NV_TRUE if the allocation is moved to the nvfp's free list.
+ */
+static inline NvBool nv_alloc_release(nv_file_private_t *nvfp, nv_alloc_t *at)
+{
+    NV_PRINT_AT(NV_DBG_MEMINFO, at);
+
+    if (NV_ATOMIC_DEC_AND_TEST(at->usage_count))
+    {
+        NV_ATOMIC_INC(at->usage_count);
+
+        at->next = nvfp->free_list;
+        nvfp->free_list = at;
+        return NV_TRUE;
+    }
+
+    return NV_FALSE;
+}
+
+/*
+ * RB_EMPTY_ROOT was added in 2.6.18 by this commit:
+ *   2006-06-21  dd67d051529387f6e44d22d1d5540ef281965fdd
+ */
+#if !defined(RB_EMPTY_ROOT)
+#define RB_EMPTY_ROOT(root) ((root)->rb_node == NULL)
+#endif
+
+/*
+ * Starting on Power9 systems, DMA addresses for NVLink are no longer
+ * the same as used over PCIe.
+ *
+ * Power9 supports a 56-bit Real Address. This address range is compressed
+ * when accessed over NVLink to allow the GPU to access all of memory using
+ * its 47-bit Physical address.
+ *
+ * If there is an NPU device present on the system, it implies that NVLink
+ * sysmem links are present and we need to apply the required address
+ * conversion for NVLink within the driver.
+ *
+ * See Bug 1920398 for further background and details.
+ *
+ * Note, a deviation from the documented compression scheme is that the
+ * upper address bits (i.e. bit 56-63) instead of being set to zero are
+ * preserved during NVLink address compression so the orignal PCIe DMA
+ * address can be reconstructed on expansion. These bits can be safely
+ * ignored on NVLink since they are truncated by the GPU.
+ *
+ * Bug 1968345: As a performance enhancement it is the responsibility of
+ * the caller on PowerPC platforms to check for presence of an NPU device
+ * before the address transformation is applied.
+ */
+static inline NvU64 nv_compress_nvlink_addr(NvU64 addr)
+{
+    NvU64 addr47 = addr;
+
+#if defined(NVCPU_PPC64LE)
+    addr47 = addr & ((1ULL << 43) - 1);
+    addr47 |= (addr & (0x3ULL << 45)) >> 2;
+    WARN_ON(addr47 & (1ULL << 44));
+    addr47 |= (addr & (0x3ULL << 49)) >> 4;
+    addr47 |= addr & ~((1ULL << 56) - 1);
+#endif
+
+    return addr47;
+}
+
+static inline NvU64 nv_expand_nvlink_addr(NvU64 addr47)
+{
+    NvU64 addr = addr47;
+
+#if defined(NVCPU_PPC64LE)
+    addr = addr47 & ((1ULL << 43) - 1);
+    addr |= (addr47 & (3ULL << 43)) << 2;
+    addr |= (addr47 & (3ULL << 45)) << 4;
+    addr |= addr47 & ~((1ULL << 56) - 1);
+#endif
+
+    return addr;
+}
+
+// Default flags for ISRs
+static inline NvU32 nv_default_irq_flags(nv_state_t *nv)
+{
+    NvU32 flags = 0;
+
+    /*
+     * Request IRQs to be disabled in our ISRs to keep consistency across the
+     * supported kernel versions.
+     *
+     * IRQF_DISABLED has been made the default in 2.6.35 with commit e58aa3d2d0cc
+     * from March 2010. And it has been later completely removed in 4.1 with commit
+     * d8bf368d0631 from March 2015. Add it to our flags if it's defined to get the
+     * same behaviour on pre-2.6.35 kernels as on recent ones.
+     */
+#if defined(IRQF_DISABLED)
+    flags |= IRQF_DISABLED;
+#endif
+
+    /*
+     * For legacy interrupts, also allow sharing. Sharing doesn't make sense
+     * for MSI(-X) as on Linux they are never shared across different devices
+     * and we only register one ISR today.
+     */
+    if ((nv->flags & (NV_FLAG_USES_MSI | NV_FLAG_USES_MSIX)) == 0)
+        flags |= IRQF_SHARED;
+
+    return flags;
+}
+
+/*
+ * From v3.7-rc1 kernel have stopped exporting get_unused_fd() and started
+ * exporting get_unused_fd_flags(), as of this commit:
+ * 2012-09-26 1a7bd2265fc ("make get_unused_fd_flags() a function")
+ */
+#if NV_IS_EXPORT_SYMBOL_PRESENT_get_unused_fd
+    #define NV_GET_UNUSED_FD()  get_unused_fd()
+#else
+    #define NV_GET_UNUSED_FD()  get_unused_fd_flags(0)
+#endif
+
+#if NV_IS_EXPORT_SYMBOL_PRESENT_get_unused_fd_flags
+    #define NV_GET_UNUSED_FD_FLAGS(flags)  get_unused_fd_flags(flags)
+#else
+    #define NV_GET_UNUSED_FD_FLAGS(flags)  (-1)
+#endif
+
+
+#if defined(NV_BACKLIGHT_DEVICE_REGISTER_PRESENT)
+#include <linux/backlight.h>
+#endif
+
+#define MODULE_BASE_NAME "nvidia"
+#define MODULE_INSTANCE_NUMBER 0
+#define MODULE_INSTANCE_STRING ""
+#define MODULE_NAME MODULE_BASE_NAME MODULE_INSTANCE_STRING
+
+NvS32 nv_request_soc_irq(nv_linux_state_t *, NvU32, nv_soc_irq_type_t, NvU32, NvU32);
+
+#endif  /* _NV_LINUX_H_ */
diff -ruN a/kernel/common/inc/nv-linux.h.rej b/kernel/common/inc/nv-linux.h.rej
--- a/kernel/common/inc/nv-linux.h.rej	1970-01-01 01:00:00.000000000 +0100
+++ b/kernel/common/inc/nv-linux.h.rej	2020-07-10 15:52:18.369263824 +0200
@@ -0,0 +1,16 @@
+--- kernel/common/inc/nv-linux.h
++++ kernel/common/inc/nv-linux.h
+@@ -509,7 +509,13 @@ extern NvBool nvos_is_chipset_io_coherent(void);
+ 
+ static inline void *nv_vmalloc(unsigned long size)
+ {
++#if NV_VMALLOC_ARGUMENT_COUNT_ARGUMENT_COUNT == 3
+     void *ptr = __vmalloc(size, GFP_KERNEL, PAGE_KERNEL);
++#elif NV_VMALLOC_ARGUMENT_COUNT_ARGUMENT_COUNT == 2
++    void *ptr = __vmalloc(size, GFP_KERNEL);
++#else
++#error "NV_VMALLOC_ARGUMENT_COUNT_ARGUMENT_COUNT value unrecognized!"
++#endif
+     if (ptr)
+         NV_MEMDBG_ADD(ptr, size);
+     return ptr;
diff -ruN a/kernel/common/inc/nv-mm.h b/kernel/common/inc/nv-mm.h
--- a/kernel/common/inc/nv-mm.h	2020-07-10 15:34:44.698455352 +0200
+++ b/kernel/common/inc/nv-mm.h	2020-07-10 15:52:18.369263824 +0200
@@ -25,6 +25,10 @@
 
 #include "conftest.h"
 
+#if defined(NV_MM_STRUCT_HAS_MMAP_LOCK)
+#define mmap_sem mmap_lock
+#endif
+
 #if !defined(NV_VM_FAULT_T_IS_PRESENT)
 typedef int vm_fault_t;
 #endif
diff -ruN a/kernel/conftest.sh b/kernel/conftest.sh
--- a/kernel/conftest.sh	2020-07-10 15:34:44.678455700 +0200
+++ b/kernel/conftest.sh	2020-07-10 15:52:18.369263824 +0200
@@ -2191,6 +2191,49 @@
             compile_check_conftest "$CODE" "NV_VZALLOC_PRESENT" "" "functions"
         ;;
 
+        vmalloc_argument_count)
+            #
+            # Determine how many arguments __vmalloc takes.
+            #
+            # Changed by commit fc3af83c4fca ("mm: remove the pgprot argument
+            # to __vmalloc")
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            #include <linux/vmalloc.h>
+            void conftest_vmalloc_argument_count(void) {
+                __vmalloc(0, GFP_KERNEL, PAGE_KERNEL);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_VMALLOC_ARGUMENT_COUNT_ARGUMENT_COUNT 3" | append_conftest "functions"
+            else
+                echo "#define NV_VMALLOC_ARGUMENT_COUNT_ARGUMENT_COUNT 2" | append_conftest "functions"
+            fi
+
+            rm -f conftest$$.o
+        ;;
+
+        mm_struct_has_mmap_lock)
+            #
+            # Determine if the mm_struct structure has 'mmap_lock'.
+            #
+            # Changed by commit ea7b54944ef9 ("mmap locking API: rename mmap_sem
+            # to mmap_lock")
+            #
+            CODE="
+            #include <linux/mm.h>
+
+            int conftest_mm_struct_has_mmap_lock(void) {
+                return offsetof(struct mm_struct, mmap_lock);
+            }"
+
+            compile_check_conftest "$CODE" "NV_MM_STRUCT_HAS_MMAP_LOCK" "" "types"
+        ;;
+
         drm_driver_has_set_busid)
             #
             # Determine if the drm_driver structure has a 'set_busid' callback
diff -ruN a/kernel/conftest.sh.orig b/kernel/conftest.sh.orig
--- a/kernel/conftest.sh.orig	1970-01-01 01:00:00.000000000 +0100
+++ b/kernel/conftest.sh.orig	2020-07-10 15:34:48.788384214 +0200
@@ -0,0 +1,4206 @@
+#!/bin/sh
+
+PATH="${PATH}:/bin:/sbin:/usr/bin"
+
+# make sure we are in the directory containing this script
+SCRIPTDIR=`dirname $0`
+cd $SCRIPTDIR
+
+CC="$1"
+ARCH=$2
+ISYSTEM=`$CC -print-file-name=include 2> /dev/null`
+SOURCES=$3
+HEADERS=$SOURCES/include
+OUTPUT=$4
+XEN_PRESENT=1
+PREEMPT_RT_PRESENT=0
+KERNEL_ARCH="$ARCH"
+
+if [ "$ARCH" = "i386" -o "$ARCH" = "x86_64" ]; then
+    if [ -d "$SOURCES/arch/x86" ]; then
+        KERNEL_ARCH="x86"
+    fi
+fi
+
+# VGX_BUILD parameter defined only for VGX builds (vGPU Host driver)
+# VGX_KVM_BUILD parameter defined only vGPU builds on KVM hypervisor
+# GRID_BUILD parameter defined only for GRID builds (GRID Guest driver)
+# GRID_BUILD_CSP parameter defined only for GRID CSP builds (GRID Guest driver for CSPs)
+
+test_xen() {
+    #
+    # Determine if the target kernel is a Xen kernel. It used to be
+    # sufficient to check for CONFIG_XEN, but the introduction of
+    # modular para-virtualization (CONFIG_PARAVIRT, etc.) and
+    # Xen guest support, it is no longer possible to determine the
+    # target environment at build time. Therefore, if both
+    # CONFIG_XEN and CONFIG_PARAVIRT are present, text_xen() treats
+    # the kernel as a stand-alone kernel.
+    #
+    if ! test_configuration_option CONFIG_XEN ||
+         test_configuration_option CONFIG_PARAVIRT; then
+        XEN_PRESENT=0
+    fi
+}
+
+append_conftest() {
+    #
+    # Echo data from stdin: this is a transitional function to make it easier
+    # to port conftests from drivers with parallel conftest generation to
+    # older driver versions
+    #
+
+    while read LINE; do
+        echo ${LINE}
+    done
+}
+
+translate_and_preprocess_header_files() {
+    # Inputs:
+    #   $1: list of relative file paths
+    #
+    # This routine creates an upper case, underscore version of each of the
+    # relative file paths, and uses that as the token to either define or
+    # undefine in a C header file. For example, linux/fence.h becomes
+    # NV_LINUX_FENCE_H_PRESENT, and that is either defined or undefined, in the
+    # output (which goes to stdout, just like the rest of this file).
+
+    # -MG or -MD can interfere with the use of -M and -M -MG for testing file
+    # existence; filter out any occurrences from CFLAGS. CFLAGS is intentionally
+    # wrapped with whitespace in the input to sed(1) so the regex can match zero
+    # or more occurrences of "-MD" or "-MG", surrounded by whitespace to avoid
+    # accidental matches with tokens that happen to contain either of those
+    # strings, without special handling of the beginning or the end of the line.
+    TEST_CFLAGS=`echo "-E -M $CFLAGS " | sed -e 's/\( -M[DG]\)* / /g'`
+
+    for file in $@; do
+        local file_define=NV_`echo $file | tr '/.' '_' | tr '-' '_' | tr 'a-z' 'A-Z'`_PRESENT
+
+        CODE="#include <$file>"
+
+        if echo "$CODE" | $CC $TEST_CFLAGS - > /dev/null 2>&1; then
+            echo "#define $file_define"
+        else
+            # If preprocessing failed, it could have been because the header
+            # file under test is not present, or because it is present but
+            # depends upon the inclusion of other header files. Attempting
+            # preprocessing again with -MG will ignore a missing header file
+            # but will still fail if the header file is present.
+            if echo "$CODE" | $CC $TEST_CFLAGS -MG - > /dev/null 2>&1; then
+                echo "#undef $file_define"
+            else
+                echo "#define $file_define"
+            fi
+        fi
+    done
+}
+
+test_headers() {
+    #
+    # Determine which header files (of a set that may or may not be
+    # present) are provided by the target kernel.
+    #
+    FILES="asm/system.h"
+    FILES="$FILES drm/drmP.h"
+    FILES="$FILES drm/drm_auth.h"
+    FILES="$FILES drm/drm_gem.h"
+    FILES="$FILES drm/drm_crtc.h"
+    FILES="$FILES drm/drm_atomic.h"
+    FILES="$FILES drm/drm_atomic_helper.h"
+    FILES="$FILES drm/drm_encoder.h"
+    FILES="$FILES drm/drm_atomic_uapi.h"
+    FILES="$FILES drm/drm_drv.h"
+    FILES="$FILES drm/drm_framebuffer.h"
+    FILES="$FILES drm/drm_connector.h"
+    FILES="$FILES drm/drm_probe_helper.h"
+    FILES="$FILES drm/drm_blend.h"
+    FILES="$FILES drm/drm_fourcc.h"
+    FILES="$FILES drm/drm_prime.h"
+    FILES="$FILES drm/drm_plane.h"
+    FILES="$FILES drm/drm_vblank.h"
+    FILES="$FILES drm/drm_file.h"
+    FILES="$FILES drm/drm_ioctl.h"
+    FILES="$FILES drm/drm_device.h"
+    FILES="$FILES generated/autoconf.h"
+    FILES="$FILES generated/compile.h"
+    FILES="$FILES generated/utsrelease.h"
+    FILES="$FILES linux/efi.h"
+    FILES="$FILES linux/kconfig.h"
+    FILES="$FILES linux/screen_info.h"
+    FILES="$FILES linux/semaphore.h"
+    FILES="$FILES linux/printk.h"
+    FILES="$FILES linux/ratelimit.h"
+    FILES="$FILES linux/prio_tree.h"
+    FILES="$FILES linux/log2.h"
+    FILES="$FILES linux/of.h"
+    FILES="$FILES linux/bug.h"
+    FILES="$FILES linux/sched/signal.h"
+    FILES="$FILES linux/sched/task.h"
+    FILES="$FILES linux/sched/task_stack.h"
+    FILES="$FILES xen/ioemu.h"
+    FILES="$FILES linux/fence.h"
+    FILES="$FILES linux/dma-resv.h"
+    FILES="$FILES soc/tegra/chip-id.h"
+    FILES="$FILES video/nv_internal.h"
+    FILES="$FILES asm/book3s/64/hash-64k.h"
+    FILES="$FILES asm/set_memory.h"
+    FILES="$FILES asm/prom.h"
+    FILES="$FILES asm/powernv.h"
+    FILES="$FILES asm/tlbflush.h"
+    FILES="$FILES linux/atomic.h"
+    FILES="$FILES asm/barrier.h"
+    FILES="$FILES asm/opal-api.h"
+    FILES="$FILES sound/hdaudio.h"
+    FILES="$FILES asm/pgtable_types.h"
+
+    translate_and_preprocess_header_files $FILES
+}
+
+build_cflags() {
+    BASE_CFLAGS="-O2 -D__KERNEL__ \
+-DKBUILD_BASENAME=\"#conftest$$\" -DKBUILD_MODNAME=\"#conftest$$\" \
+-nostdinc -isystem $ISYSTEM"
+
+    if [ "$OUTPUT" != "$SOURCES" ]; then
+        OUTPUT_CFLAGS="-I$OUTPUT/include2 -I$OUTPUT/include"
+        if [ -f "$OUTPUT/include/generated/autoconf.h" ]; then
+            AUTOCONF_FILE="$OUTPUT/include/generated/autoconf.h"
+        else
+            AUTOCONF_FILE="$OUTPUT/include/linux/autoconf.h"
+        fi
+    else
+        if [ -f "$HEADERS/generated/autoconf.h" ]; then
+            AUTOCONF_FILE="$HEADERS/generated/autoconf.h"
+        else
+            AUTOCONF_FILE="$HEADERS/linux/autoconf.h"
+        fi
+    fi
+
+    test_xen
+
+    if [ "$XEN_PRESENT" != "0" ]; then
+        MACH_CFLAGS="-I$HEADERS/asm/mach-xen"
+    fi
+
+    SOURCE_HEADERS="$HEADERS"
+    SOURCE_ARCH_HEADERS="$SOURCES/arch/$KERNEL_ARCH/include"
+    OUTPUT_HEADERS="$OUTPUT/include"
+    OUTPUT_ARCH_HEADERS="$OUTPUT/arch/$KERNEL_ARCH/include"
+
+    # Look for mach- directories on this arch, and add it to the list of
+    # includes if that platform is enabled in the configuration file, which
+    # may have a definition like this:
+    #   #define CONFIG_ARCH_<MACHUPPERCASE> 1
+    for _mach_dir in `ls -1d $SOURCES/arch/$KERNEL_ARCH/mach-* 2>/dev/null`; do
+        _mach=`echo $_mach_dir | \
+            sed -e "s,$SOURCES/arch/$KERNEL_ARCH/mach-,," | \
+            tr 'a-z' 'A-Z'`
+        grep "CONFIG_ARCH_$_mach \+1" $AUTOCONF_FILE > /dev/null 2>&1
+        if [ $? -eq 0 ]; then
+            MACH_CFLAGS="$MACH_CFLAGS -I$_mach_dir/include"
+        fi
+    done
+
+    if [ "$ARCH" = "arm" ]; then
+        MACH_CFLAGS="$MACH_CFLAGS -D__LINUX_ARM_ARCH__=7"
+    fi
+
+    # Add the mach-default includes (only found on x86/older kernels)
+    MACH_CFLAGS="$MACH_CFLAGS -I$SOURCE_HEADERS/asm-$KERNEL_ARCH/mach-default"
+    MACH_CFLAGS="$MACH_CFLAGS -I$SOURCE_ARCH_HEADERS/asm/mach-default"
+
+    CFLAGS="$BASE_CFLAGS $MACH_CFLAGS $OUTPUT_CFLAGS -include $AUTOCONF_FILE"
+    CFLAGS="$CFLAGS -I$SOURCE_HEADERS"
+    CFLAGS="$CFLAGS -I$SOURCE_HEADERS/uapi"
+    CFLAGS="$CFLAGS -I$SOURCE_HEADERS/xen"
+    CFLAGS="$CFLAGS -I$OUTPUT_HEADERS/generated/uapi"
+    CFLAGS="$CFLAGS -I$SOURCE_ARCH_HEADERS"
+    CFLAGS="$CFLAGS -I$SOURCE_ARCH_HEADERS/uapi"
+    CFLAGS="$CFLAGS -I$OUTPUT_ARCH_HEADERS/generated"
+    CFLAGS="$CFLAGS -I$OUTPUT_ARCH_HEADERS/generated/uapi"
+
+    if [ -n "$BUILD_PARAMS" ]; then
+        CFLAGS="$CFLAGS -D$BUILD_PARAMS"
+    fi
+
+    # Check if gcc supports asm goto and set CC_HAVE_ASM_GOTO if it does.
+    # Older kernels perform this check and set this flag in Kbuild, and since
+    # conftest.sh runs outside of Kbuild it ends up building without this flag.
+    # Starting with commit e9666d10a5677a494260d60d1fa0b73cc7646eb3 this test
+    # is done within Kconfig, and the preprocessor flag is no longer needed.
+
+    GCC_GOTO_SH="$SOURCES/build/gcc-goto.sh"
+
+    if [ -f "$GCC_GOTO_SH" ]; then
+        # Newer versions of gcc-goto.sh don't print anything on success, but
+        # this is okay, since it's no longer necessary to set CC_HAVE_ASM_GOTO
+        # based on the output of those versions of gcc-goto.sh.
+        if [ `/bin/sh "$GCC_GOTO_SH" "$CC"` = "y" ]; then
+            CFLAGS="$CFLAGS -DCC_HAVE_ASM_GOTO"
+        fi
+    fi
+}
+
+CONFTEST_PREAMBLE="#include \"conftest/headers.h\"
+    #if defined(NV_LINUX_KCONFIG_H_PRESENT)
+    #include <linux/kconfig.h>
+    #endif
+    #if defined(NV_GENERATED_AUTOCONF_H_PRESENT)
+    #include <generated/autoconf.h>
+    #else
+    #include <linux/autoconf.h>
+    #endif
+    #if defined(CONFIG_XEN) && \
+        defined(CONFIG_XEN_INTERFACE_VERSION) &&  !defined(__XEN_INTERFACE_VERSION__)
+    #define __XEN_INTERFACE_VERSION__ CONFIG_XEN_INTERFACE_VERSION
+    #endif"
+
+test_configuration_option() {
+    #
+    # Check to see if the given configuration option is defined
+    #
+
+    get_configuration_option $1 >/dev/null 2>&1
+
+    return $?
+
+}
+
+set_configuration() {
+    #
+    # Set a specific configuration option.  This function is called to always
+    # enable a configuration, in order to verify whether the test code for that
+    # configuration is no longer required and the corresponding
+    # conditionally-compiled code in the driver can be removed.
+    #
+    DEF="$1"
+
+    if [ "$3" = "" ]
+    then
+        VAL=""
+        CAT="$2"
+    else
+        VAL="$2"
+        CAT="$3"
+    fi
+
+    echo "#define ${DEF} ${VAL}" | append_conftest "${CAT}"
+}
+
+unset_configuration() {
+    #
+    # Un-set a specific configuration option.  This function is called to
+    # always disable a configuration, in order to verify whether the test
+    # code for that configuration is no longer required and the corresponding
+    # conditionally-compiled code in the driver can be removed.
+    #
+    DEF="$1"
+    CAT="$2"
+
+    echo "#undef ${DEF}" | append_conftest "${CAT}"
+}
+
+compile_check_conftest() {
+    #
+    # Compile the current conftest C file and check+output the result
+    #
+    CODE="$1"
+    DEF="$2"
+    VAL="$3"
+    CAT="$4"
+
+    echo "$CONFTEST_PREAMBLE
+    $CODE" > conftest$$.c
+
+    $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+    rm -f conftest$$.c
+
+    if [ -f conftest$$.o ]; then
+        rm -f conftest$$.o
+        if [ "${CAT}" = "functions" ]; then
+            #
+            # The logic for "functions" compilation tests is inverted compared to
+            # other compilation steps: if the function is present, the code
+            # snippet will fail to compile because the function call won't match
+            # the prototype. If the function is not present, the code snippet
+            # will produce an object file with the function as an unresolved
+            # symbol.
+            #
+            echo "#undef ${DEF}" | append_conftest "${CAT}"
+        else
+            echo "#define ${DEF} ${VAL}" | append_conftest "${CAT}"
+        fi
+        return
+    else
+        if [ "${CAT}" = "functions" ]; then
+            echo "#define ${DEF} ${VAL}" | append_conftest "${CAT}"
+        else
+            echo "#undef ${DEF}" | append_conftest "${CAT}"
+        fi
+        return
+    fi
+}
+
+export_symbol_present_conftest() {
+    #
+    # Check Module.symvers to see whether the given symbol is present.
+    #
+
+    SYMBOL="$1"
+    TAB='	'
+
+    if grep -e "${TAB}${SYMBOL}${TAB}.*${TAB}EXPORT_SYMBOL.*\$" \
+               "$OUTPUT/Module.symvers" >/dev/null 2>&1; then
+        echo "#define NV_IS_EXPORT_SYMBOL_PRESENT_$SYMBOL 1" |
+            append_conftest "symbols"
+    else
+        # May be a false negative if Module.symvers is absent or incomplete,
+        # or if the Module.symvers format changes.
+        echo "#define NV_IS_EXPORT_SYMBOL_PRESENT_$SYMBOL 0" |
+            append_conftest "symbols"
+    fi
+}
+
+export_symbol_gpl_conftest() {
+    #
+    # Check Module.symvers to see whether the given symbol is present and its
+    # export type is GPL-only (including deprecated GPL-only symbols).
+    #
+
+    SYMBOL="$1"
+    TAB='	'
+
+    if grep -e "${TAB}${SYMBOL}${TAB}.*${TAB}EXPORT_\(UNUSED_\)*SYMBOL_GPL\$" \
+               "$OUTPUT/Module.symvers" >/dev/null 2>&1; then
+        echo "#define NV_IS_EXPORT_SYMBOL_GPL_$SYMBOL 1" |
+            append_conftest "symbols"
+    else
+        # May be a false negative if Module.symvers is absent or incomplete,
+        # or if the Module.symvers format changes.
+        echo "#define NV_IS_EXPORT_SYMBOL_GPL_$SYMBOL 0" |
+            append_conftest "symbols"
+    fi
+}
+
+get_configuration_option() {
+    #
+    # Print the value of given configuration option, if defined
+    #
+    RET=1
+    OPTION=$1
+
+    OLD_FILE="linux/autoconf.h"
+    NEW_FILE="generated/autoconf.h"
+    FILE=""
+
+    if [ -f $HEADERS/$NEW_FILE -o -f $OUTPUT/include/$NEW_FILE ]; then
+        FILE=$NEW_FILE
+    elif [ -f $HEADERS/$OLD_FILE -o -f $OUTPUT/include/$OLD_FILE ]; then
+        FILE=$OLD_FILE
+    fi
+
+    if [ -n "$FILE" ]; then
+        #
+        # We are looking at a configured source tree; verify
+        # that its configuration includes the given option
+        # via a compile check, and print the option's value.
+        #
+
+        if [ -f $HEADERS/$FILE ]; then
+            INCLUDE_DIRECTORY=$HEADERS
+        elif [ -f $OUTPUT/include/$FILE ]; then
+            INCLUDE_DIRECTORY=$OUTPUT/include
+        else
+            return 1
+        fi
+
+        echo "#include <$FILE>
+        #ifndef $OPTION
+        #error $OPTION not defined!
+        #endif
+
+        $OPTION
+        " > conftest$$.c
+
+        $CC -E -P -I$INCLUDE_DIRECTORY -o conftest$$ conftest$$.c > /dev/null 2>&1
+
+        if [ -e conftest$$ ]; then
+            tr -d '\r\n\t ' < conftest$$
+            RET=$?
+        fi
+
+        rm -f conftest$$.c conftest$$
+    else
+        CONFIG=$OUTPUT/.config
+        if [ -f $CONFIG ] && grep "^$OPTION=" $CONFIG; then
+            grep "^$OPTION=" $CONFIG | cut -f 2- -d "="
+            RET=$?
+        fi
+    fi
+
+    return $RET
+
+}
+
+compile_test() {
+    case "$1" in
+        set_memory_uc)
+            #
+            # Determine if the set_memory_uc() function is present.
+            # It does not exist on all architectures.
+            #
+            CODE="
+            #if defined(NV_ASM_SET_MEMORY_H_PRESENT)
+            #if defined(NV_ASM_PGTABLE_TYPES_H_PRESENT)
+            #include <asm/pgtable_types.h>
+            #endif
+            #include <asm/set_memory.h>
+            #else
+            #include <asm/cacheflush.h>
+            #endif
+            void conftest_set_memory_uc(void) {
+                set_memory_uc();
+            }"
+
+            compile_check_conftest "$CODE" "NV_SET_MEMORY_UC_PRESENT" "" "functions"
+        ;;
+
+        set_memory_array_uc)
+            #
+            # Determine if the set_memory_array_uc() function is present.
+            # It does not exist on all architectures.
+            #
+            CODE="
+            #if defined(NV_ASM_SET_MEMORY_H_PRESENT)
+            #if defined(NV_ASM_PGTABLE_TYPES_H_PRESENT)
+            #include <asm/pgtable_types.h>
+            #endif
+            #include <asm/set_memory.h>
+            #else
+            #include <asm/cacheflush.h>
+            #endif
+            void conftest_set_memory_array_uc(void) {
+                set_memory_array_uc();
+            }"
+
+            compile_check_conftest "$CODE" "NV_SET_MEMORY_ARRAY_UC_PRESENT" "" "functions"
+        ;;
+
+        sysfs_slab_unlink)
+            #
+            # Determine if the sysfs_slab_unlink() function is present.
+            #
+            # This test is useful to check for the presence a fix for the deferred
+            # kmem_cache destroy feature (see nvbug: 2543505).
+            #
+            # Added by commit d50d82faa0c9 ("slub: fix failure when we delete and
+            # create a slab cache") in 4.18 (2018-06-27).
+            #
+            CODE="
+            #include <linux/slab.h>
+            void conftest_sysfs_slab_unlink(void) {
+                sysfs_slab_unlink();
+            }"
+
+            compile_check_conftest "$CODE" "NV_SYSFS_SLAB_UNLINK_PRESENT" "" "functions"
+        ;;
+
+        list_is_first)
+            #
+            # Determine if the list_is_first() function is present.
+            #
+            # Added by commit 70b44595eafe ("mm, compaction: use free lists
+            # to quickly locate a migration source") in 5.1 (2019-03-05)
+            #
+            CODE="
+            #include <linux/list.h>
+            void conftest_list_is_first(void) {
+                list_is_first();
+            }"
+
+            compile_check_conftest "$CODE" "NV_LIST_IS_FIRST_PRESENT" "" "functions"
+        ;;
+
+        set_pages_uc)
+            #
+            # Determine if the set_pages_uc() function is present.
+            # It does not exist on all architectures.
+            #
+            CODE="
+            #if defined(NV_ASM_SET_MEMORY_H_PRESENT)
+            #if defined(NV_ASM_PGTABLE_TYPES_H_PRESENT)
+            #include <asm/pgtable_types.h>
+            #endif
+            #include <asm/set_memory.h>
+            #else
+            #include <asm/cacheflush.h>
+            #endif
+            void conftest_set_pages_uc(void) {
+                set_pages_uc();
+            }"
+
+            compile_check_conftest "$CODE" "NV_SET_PAGES_UC_PRESENT" "" "functions"
+        ;;
+
+        set_pages_array_uc)
+            #
+            # Determine if the set_pages_array_uc() function is present.
+            # It does not exist on all architectures.
+            #
+            # set_pages_array_uc() was added by commit
+            # 0f3507555f6fa4acbc85a646d6e8766230db38fc ("x86, CPA: Add
+            # set_pages_arrayuc and set_pages_array_wb") in v2.6.30-rc1 (Thu Mar
+            # 19 14:51:15 2009)
+            #
+            CODE="
+            #if defined(NV_ASM_SET_MEMORY_H_PRESENT)
+            #if defined(NV_ASM_PGTABLE_TYPES_H_PRESENT)
+            #include <asm/pgtable_types.h>
+            #endif
+            #include <asm/set_memory.h>
+            #else
+            #include <asm/cacheflush.h>
+            #endif
+            void conftest_set_pages_array_uc(void) {
+                set_pages_array_uc();
+            }"
+
+            compile_check_conftest "$CODE" "NV_SET_PAGES_ARRAY_UC_PRESENT" "" "functions"
+        ;;
+
+        outer_flush_all)
+            #
+            # Determine if the outer_cache_fns struct has flush_all member.
+            #
+            # Added by commit ae360a78f411 ("arm: Disable outer (L2) cache
+            # in kexec") in 2.6.37.  Present only in arch/arm.
+            #
+            CODE="
+            #include <asm/outercache.h>
+            int conftest_outer_flush_all(void) {
+                return offsetof(struct outer_cache_fns, flush_all);
+            }"
+
+            compile_check_conftest "$CODE" "NV_OUTER_FLUSH_ALL_PRESENT" "" "types"
+        ;;
+
+        flush_cache_all)
+            #
+            # Determine if flush_cache_all() function is present
+            #
+            # flush_cache_all() was removed by commit id
+            # 68234df4ea79 ("arm64: kill flush_cache_all()") in 4.2 (2015-04-20)
+            # for aarch64
+            #
+            CODE="
+            #include <asm/cacheflush.h>
+            int conftest_flush_cache_all(void) {
+                return flush_cache_all();
+            }"
+            compile_check_conftest "$CODE" "NV_FLUSH_CACHE_ALL_PRESENT" "" "functions"
+        ;;
+
+        pci_get_domain_bus_and_slot)
+            #
+            # Determine if the pci_get_domain_bus_and_slot() function
+            # is present.
+            #
+            # Added by commit 3c299dc22635 ("PCI: add
+            # pci_get_domain_bus_and_slot function") in 2.6.33.
+            #
+            CODE="
+            #include <linux/pci.h>
+            void conftest_pci_get_domain_bus_and_slot(void) {
+                pci_get_domain_bus_and_slot();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PCI_GET_DOMAIN_BUS_AND_SLOT_PRESENT" "" "functions"
+        ;;
+
+        pci_bus_address)
+            #
+            # Determine if the pci_bus_address() function is
+            # present.
+            #
+            # Added by commit 06cf56e497c8 ("PCI: Add pci_bus_address() to
+            # get bus address of a BAR") in v3.14
+            #
+            CODE="
+            #include <linux/pci.h>
+            void conftest_pci_bus_address(void) {
+                pci_bus_address();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PCI_BUS_ADDRESS_PRESENT" "" "functions"
+        ;;
+
+        hash__remap_4k_pfn)
+            #
+            # Determine if the hash__remap_4k_pfn() function is
+            # present.
+            #
+            # Added by commit 6cc1a0ee4ce2 ("powerpc/mm/radix: Add radix
+            # callback for pmd accessors") in v4.7 (committed 2016-04-29).
+            # Present only in arch/powerpc
+            #
+            CODE="
+            #if defined(NV_ASM_BOOK3S_64_HASH_64K_H_PRESENT)
+            #include <linux/mm.h>
+            #include <asm/book3s/64/hash-64k.h>
+            #endif
+            void conftest_hash__remap_4k_pfn(void) {
+                hash__remap_4k_pfn();
+            }"
+
+            compile_check_conftest "$CODE" "NV_HASH__REMAP_4K_PFN_PRESENT" "" "functions"
+        ;;
+
+        acpi_op_remove)
+            #
+            # Determine the number of arguments to pass to the
+            # 'acpi_op_remove' routine.
+            #
+            # Second parameter removed by commit 51fac8388a03
+            # ("ACPI: Remove useless type argument of driver .remove()
+            # operation") in v3.9
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/acpi.h>
+
+            acpi_op_remove conftest_op_remove_routine;
+
+            int conftest_acpi_device_ops_remove(struct acpi_device *device) {
+                return conftest_op_remove_routine(device);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                echo "#define NV_ACPI_DEVICE_OPS_REMOVE_ARGUMENT_COUNT 1" | append_conftest "types"
+                return
+            fi
+
+            CODE="
+            #include <linux/acpi.h>
+
+            acpi_op_remove conftest_op_remove_routine;
+
+            int conftest_acpi_device_ops_remove(struct acpi_device *device, int type) {
+                return conftest_op_remove_routine(device, type);
+            }"
+
+            compile_check_conftest "$CODE" "NV_ACPI_DEVICE_OPS_REMOVE_ARGUMENT_COUNT" "2" "types"
+        ;;
+
+        acquire_console_sem)
+            #
+            # Determine if the acquire_console_sem() function
+            # is present.
+            #
+            # Function was renamed to console_lock() by commit ac751efa6a0d
+            # ("console: rename acquire/release_console_sem() to
+            # console_lock/unlock()") in v2.6.38
+            #
+            CODE="
+            #include <linux/console.h>
+            void conftest_acquire_console_sem(void) {
+                acquire_console_sem(NULL);
+            }"
+
+            compile_check_conftest "$CODE" "NV_ACQUIRE_CONSOLE_SEM_PRESENT" "" "functions"
+        ;;
+
+        console_lock)
+            #
+            # Determine if the console_lock() function is present.
+            #
+            # Added by commit ac751efa6a0d ("console: rename
+            # acquire/release_console_sem() to console_lock/unlock()") in
+            # v2.6.38.  Function was renamed from acquire_console_sem()
+            #
+            CODE="
+            #include <linux/console.h>
+            void conftest_console_lock(void) {
+                console_lock(NULL);
+            }"
+
+            compile_check_conftest "$CODE" "NV_CONSOLE_LOCK_PRESENT" "" "functions"
+        ;;
+
+        register_cpu_notifier)
+            #
+            # Determine if register_cpu_notifier() is present
+            #
+            # Removed by commit 530e9b76ae8f ("cpu/hotplug: Remove obsolete
+            # cpu hotplug register/unregister functions") in v4.10
+            # (2016-12-21)
+            #
+            CODE="
+            #include <linux/cpu.h>
+            void conftest_register_cpu_notifier(void) {
+                register_cpu_notifier();
+            }" > conftest$$.c
+            compile_check_conftest "$CODE" "NV_REGISTER_CPU_NOTIFIER_PRESENT" "" "functions"
+        ;;
+
+        cpuhp_setup_state)
+            #
+            # Determine if cpuhp_setup_state() is present
+            #
+            # Added by commit 5b7aa87e0482 ("cpu/hotplug: Implement
+            # setup/removal interface") in v4.6 (commited 2016-02-26)
+            #
+            # It is used as a replacement for register_cpu_notifier
+            CODE="
+            #include <linux/cpu.h>
+            void conftest_cpuhp_setup_state(void) {
+                cpuhp_setup_state();
+            }" > conftest$$.c
+            compile_check_conftest "$CODE" "NV_CPUHP_SETUP_STATE_PRESENT" "" "functions"
+        ;;
+
+        acpi_walk_namespace)
+            #
+            # Determine how many arguments acpi_walk_namespace() takes.
+            #
+            # Seventh parameter added by commit 2263576cfc6e
+            # ("ACPICA: Add post-order callback to acpi_walk_namespace")
+            # in v2.6.33
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/acpi.h>
+            void conftest_acpi_walk_namespace(void) {
+                acpi_walk_namespace(0, NULL, 0, NULL, NULL, NULL, NULL);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                echo "#define NV_ACPI_WALK_NAMESPACE_PRESENT" | append_conftest "functions"
+                echo "#define NV_ACPI_WALK_NAMESPACE_ARGUMENT_COUNT 7" | append_conftest "functions"
+                return
+            fi
+
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/acpi.h>
+            void conftest_acpi_walk_namespace(void) {
+                acpi_walk_namespace(0, NULL, 0, NULL, NULL, NULL);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                echo "#define NV_ACPI_WALK_NAMESPACE_PRESENT" | append_conftest "functions"
+                echo "#define NV_ACPI_WALK_NAMESPACE_ARGUMENT_COUNT 6" | append_conftest "functions"
+                return
+            else
+                echo "#error acpi_walk_namespace() conftest failed!" | append_conftest "functions"
+            fi
+        ;;
+
+        ioremap_cache)
+            #
+            # Determine if the ioremap_cache() function is present.
+            # It does not exist on all architectures.
+            #
+            CODE="
+            #include <asm/io.h>
+            void conftest_ioremap_cache(void) {
+                ioremap_cache();
+            }"
+
+            compile_check_conftest "$CODE" "NV_IOREMAP_CACHE_PRESENT" "" "functions"
+        ;;
+
+        ioremap_wc)
+            #
+            # Determine if the ioremap_wc() function is present.
+            # It does not exist on all architectures.
+            #
+            CODE="
+            #include <asm/io.h>
+            void conftest_ioremap_wc(void) {
+                ioremap_wc();
+            }"
+
+            compile_check_conftest "$CODE" "NV_IOREMAP_WC_PRESENT" "" "functions"
+        ;;
+
+        file_operations)
+            # 'ioctl' field removed by commit b19dd42faf41
+            # ("bkl: Remove locked .ioctl file operation") in v2.6.36
+            CODE="
+            #include <linux/fs.h>
+            int conftest_file_operations(void) {
+                return offsetof(struct file_operations, ioctl);
+            }"
+
+            compile_check_conftest "$CODE" "NV_FILE_OPERATIONS_HAS_IOCTL" "" "types"
+        ;;
+
+        sg_alloc_table)
+            #
+            # sg_alloc_table_from_pages added by commit efc42bc98058
+            # ("scatterlist: add sg_alloc_table_from_pages function") in v3.6
+            #
+            CODE="
+            #include <linux/scatterlist.h>
+            void conftest_sg_alloc_table_from_pages(void) {
+                sg_alloc_table_from_pages();
+            }"
+
+            compile_check_conftest "$CODE" "NV_SG_ALLOC_TABLE_FROM_PAGES_PRESENT" "" "functions"
+        ;;
+
+        efi_enabled)
+            #
+            # Added in 2.6.12 as a variable
+            #
+            # Determine if the efi_enabled symbol is present (as a variable),
+            # or if the efi_enabled() function is present and how many
+            # arguments it takes.
+            #
+            # Converted from a variable to a function by commit 83e68189745a
+            # ("efi: Make 'efi_enabled' a function to query EFI facilities")
+            # in v3.8
+            #
+            echo "$CONFTEST_PREAMBLE
+            #if defined(NV_LINUX_EFI_H_PRESENT)
+            #include <linux/efi.h>
+            #endif
+            int conftest_efi_enabled(void) {
+                return efi_enabled(0);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_EFI_ENABLED_PRESENT" | append_conftest "functions"
+                echo "#define NV_EFI_ENABLED_ARGUMENT_COUNT 1" | append_conftest "functions"
+                rm -f conftest$$.o
+                return
+            else
+                echo "#define NV_EFI_ENABLED_PRESENT" | append_conftest "symbols"
+                return
+            fi
+        ;;
+
+        dom0_kernel_present)
+            # Add config parameter if running on DOM0.
+            if [ -n "$VGX_BUILD" ]; then
+                echo "#define NV_DOM0_KERNEL_PRESENT" | append_conftest "generic"
+            else
+                echo "#undef NV_DOM0_KERNEL_PRESENT" | append_conftest "generic"
+            fi
+            return
+        ;;
+
+        nvidia_vgpu_kvm_build)
+           # Add config parameter if running on KVM host.
+           if [ -n "$VGX_KVM_BUILD" ]; then
+                echo "#define NV_VGPU_KVM_BUILD" | append_conftest "generic"
+            else
+                echo "#undef NV_VGPU_KVM_BUILD" | append_conftest "generic"
+            fi
+            return
+        ;;
+
+        nvidia_vgpu_hyperv_available)
+            # Add config parameter if running on HyperV guest.
+            if test_configuration_option CONFIG_HYPERV_MODULE; then
+                echo "#define NV_VGPU_HYPERV_BUILD" | append_conftest "generic"
+            else
+                echo "#undef NV_VGPU_HYPERV_BUILD" | append_conftest "generic"
+            fi
+            return;
+        ;;
+
+        vfio_register_notifier)
+            #
+            # Check number of arguments required.
+            #
+            # New parameters added by commit 22195cbd3451 ("vfio:
+            # vfio_register_notifier: classify iommu notifier") in v4.10
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/vfio.h>
+            int conftest_vfio_register_notifier(void) {
+                return vfio_register_notifier((struct device *) NULL, (struct notifier_block *) NULL);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_VFIO_NOTIFIER_ARGUMENT_COUNT 2" | append_conftest "functions"
+                rm -f conftest$$.o
+                return
+            else
+                echo "#define NV_VFIO_NOTIFIER_ARGUMENT_COUNT 4" | append_conftest "functions"
+                return
+            fi
+        ;;
+
+        vfio_info_add_capability_has_cap_type_id_arg)
+            #
+            # Check if vfio_info_add_capability() has cap_type_id parameter.
+            #
+            # Removed by commit dda01f787df9 ("vfio: Simplify capability
+            # helper") in v4.16 (2017-12-12)
+            #
+            CODE="
+            #include <linux/vfio.h>
+            int vfio_info_add_capability(struct vfio_info_cap *caps,
+                                         int cap_type_id,
+                                         void *cap_type) {
+                return 0;
+            }"
+
+            compile_check_conftest "$CODE" "NV_VFIO_INFO_ADD_CAPABILITY_HAS_CAP_TYPE_ID_ARGS" "" "types"
+        ;;
+
+        vmbus_channel_has_ringbuffer_page)
+            #
+            # Check if ringbuffer_page field exist in vmbus_channel structure
+            #
+            # Changed in commit 52a42c2a90226dc61c99bbd0cb096deeb52c334b
+            # ("vmbus: keep pointer to ring buffer page") in v5.0 (2018-09-14)
+            #
+
+            CODE="
+            #include <linux/hyperv.h>
+
+            int conftest_vmbus_channel_has_ringbuffer_page(void) {
+                    return offsetof(struct vmbus_channel, ringbuffer_page);
+            }"
+
+            compile_check_conftest "$CODE" "NV_VMBUS_CHANNEL_HAS_RING_BUFFER_PAGE" "" "types"
+        ;;
+
+        nvidia_grid_build)
+            if [ -n "$GRID_BUILD" ]; then
+                echo "#define NV_GRID_BUILD" | append_conftest "generic"
+            else
+                echo "#undef NV_GRID_BUILD" | append_conftest "generic"
+            fi
+            return
+        ;;
+
+        nvidia_grid_csp_build)
+            if [ -n "$GRID_BUILD_CSP" ]; then
+                echo "#define NV_GRID_BUILD_CSP $GRID_BUILD_CSP" | append_conftest "generic"
+            else
+                echo "#undef NV_GRID_BUILD_CSP" | append_conftest "generic"
+            fi
+            return
+        ;;
+
+        vm_fault_has_address)
+            #
+            # Determine if the 'vm_fault' structure has an 'address', or a
+            # 'virtual_address' field. The .virtual_address field was
+            # effectively renamed to .address:
+            #
+            # 'address' added by commit 82b0f8c39a38 ("mm: join
+            # struct fault_env and vm_fault") in v4.10 (2016-12-14)
+            #
+            # 'virtual_address' removed by commit 1a29d85eb0f1 ("mm: use
+            # vmf->address instead of of vmf->virtual_address") in v4.10
+            # (2016-12-14)
+            #
+            CODE="
+            #include <linux/mm.h>
+            int conftest_vm_fault_has_address(void) {
+                return offsetof(struct vm_fault, address);
+            }"
+
+            compile_check_conftest "$CODE" "NV_VM_FAULT_HAS_ADDRESS" "" "types"
+        ;;
+
+        kmem_cache_has_kobj_remove_work)
+            #
+            # Determine if the 'kmem_cache' structure has 'kobj_remove_work'.
+            #
+            # 'kobj_remove_work' was added by commit 3b7b314053d02 ("slub: make
+            # sysfs file removal asynchronous") in v4.12 (2017-06-23). This
+            # commit introduced a race between kmem_cache destroy and create
+            # which we need to workaround in our driver (see nvbug: 2543505).
+            # Also see comment for sysfs_slab_unlink conftest.
+            #
+            CODE="
+            #include <linux/mm.h>
+            #include <linux/slab.h>
+            #include <linux/slub_def.h>
+            int conftest_kmem_cache_has_kobj_remove_work(void) {
+                return offsetof(struct kmem_cache, kobj_remove_work);
+            }"
+
+            compile_check_conftest "$CODE" "NV_KMEM_CACHE_HAS_KOBJ_REMOVE_WORK" "" "types"
+        ;;
+
+        mdev_uuid)
+            #
+            # Determine if mdev_uuid() function is present or not
+            #
+            # Added by commit 99e3123e3d72 ("vfio-mdev: Make mdev_device
+            # private and abstract interfaces") in v4.10
+            #
+            CODE="
+            #include <linux/pci.h>
+            #include <linux/mdev.h>
+            void conftest_mdev_uuid() {
+                mdev_uuid();
+            }"
+
+            compile_check_conftest "$CODE" "NV_MDEV_UUID_PRESENT" "" "functions"
+
+            #
+            # Determine if mdev_uuid() returns 'const guid_t *'.
+            #
+            # mdev_uuid() function prototype updated to return 'const guid_t *'
+            # by commit 278bca7f318e ("vfio-mdev: Switch to use new generic UUID
+            # API") in v5.1 (2019-01-10).
+            #
+            CODE="
+            #include <linux/pci.h>
+            #include <linux/mdev.h>
+            const guid_t *conftest_mdev_uuid_return_guid_ptr(struct mdev_device *mdev) {
+                return mdev_uuid(mdev);
+            }"
+
+            compile_check_conftest "$CODE" "NV_MDEV_UUID_RETURN_GUID_PTR" "" "types"
+        ;;
+
+        mdev_dev)
+            #
+            # Determine if mdev_dev() function is present or not
+            #
+            # Added by commit 99e3123e3d72 ("vfio-mdev: Make mdev_device
+            # private and abstract interfaces") in v4.10
+            #
+            CODE="
+            #include <linux/pci.h>
+            #include <linux/mdev.h>
+            void conftest_mdev_dev() {
+                mdev_dev();
+            }"
+
+            compile_check_conftest "$CODE" "NV_MDEV_DEV_PRESENT" "" "functions"
+        ;;
+
+        mdev_parent)
+            #
+            # Determine if the struct mdev_parent type is present.
+            #
+            # Added by commit 42930553a7c1 ("vfio-mdev: de-polute the
+            # namespace, rename parent_device & parent_ops") in v4.10
+            #
+            CODE="
+            #include <linux/pci.h>
+            #include <linux/mdev.h>
+            struct mdev_parent_ops conftest_mdev_parent;
+            "
+
+            compile_check_conftest "$CODE" "NV_MDEV_PARENT_OPS_STRUCT_PRESENT" "" "types"
+        ;;
+
+        mdev_parent_dev)
+            #
+            # Determine if mdev_parent_dev() function is present or not
+            #
+            # Added by commit 9372e6feaafb ("vfio-mdev: Make mdev_parent
+            # private") in v4.10
+            #
+            CODE="
+            #include <linux/pci.h>
+            #include <linux/mdev.h>
+            void conftest_mdev_parent_dev() {
+                mdev_parent_dev();
+            }"
+
+            compile_check_conftest "$CODE" "NV_MDEV_PARENT_DEV_PRESENT" "" "functions"
+        ;;
+
+        mdev_from_dev)
+            #
+            # Determine if mdev_from_dev() function is present or not.
+            #
+            # Added by commit 99e3123e3d72 ("vfio-mdev: Make mdev_device
+            # private and abstract interfaces") in v4.10 (2016-12-30)
+            #
+            CODE="
+            #include <linux/pci.h>
+            #include <linux/mdev.h>
+            void conftest_mdev_from_dev() {
+                mdev_from_dev();
+            }"
+
+            compile_check_conftest "$CODE" "NV_MDEV_FROM_DEV_PRESENT" "" "functions"
+        ;;
+
+        mdev_set_iommu_device)
+            #
+            # Determine if mdev_set_iommu_device() function is present or not.
+            #
+            # Added by commit 8ac13175cbe9 ("vfio/mdev: Add iommu related member
+            # in mdev_device) in v5.1 (2019-04-12)
+            #
+            CODE="
+            #include <linux/pci.h>
+            #include <linux/mdev.h>
+            void conftest_mdev_set_iommu_device() {
+                mdev_set_iommu_device();
+            }"
+
+            compile_check_conftest "$CODE" "NV_MDEV_SET_IOMMU_DEVICE_PRESENT" "" "functions"
+        ;;
+
+        pci_irq_vector_helpers)
+            #
+            # Determine if pci_alloc_irq_vectors(), pci_free_irq_vectors()
+            # functions are present or not.
+            #
+            # Added by commit aff171641d181ea573 (PCI: Provide sensible IRQ
+            # vector alloc/free routines) (2016-07-12)
+            #
+            CODE="
+            #include <linux/pci.h>
+            #include <linux/msi.h>
+            void conftest_pci_irq_vector_helpers() {
+                pci_alloc_irq_vectors();
+                pci_free_irq_vectors ();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PCI_IRQ_VECTOR_HELPERS_PRESENT" "" "functions"
+        ;;
+
+
+        vfio_device_gfx_plane_info)
+            #
+            # determine if the 'struct vfio_device_gfx_plane_info' type is present.
+            #
+            # Added by commit e20eaa2382e7 ("vfio: ABI for mdev display
+            # dma-buf operation") in v4.16 (2017-11-23)
+            #
+            CODE="
+            #include <linux/vfio.h>
+            struct vfio_device_gfx_plane_info info;"
+
+            compile_check_conftest "$CODE" "NV_VFIO_DEVICE_GFX_PLANE_INFO_PRESENT" "" "types"
+        ;;
+
+        vfio_device_migration_info)
+            #
+            # determine if the 'struct vfio_device_migration_info' type is present.
+            #
+            # Proposed interface for vGPU Migration
+            # ("[PATCH v3 0/5] Add migration support for VFIO device ")
+            # https://lists.gnu.org/archive/html/qemu-devel/2019-02/msg05176.html
+            # Upstreamed commit a8a24f3f6e38 (vfio: UAPI for migration interface
+            # for device state) in v5.8 (2020-05-29)
+            #
+            CODE="
+            #include <linux/vfio.h>
+            struct vfio_device_migration_info info;"
+
+            compile_check_conftest "$CODE" "NV_VFIO_DEVICE_MIGRATION_INFO_PRESENT" "" "types"
+        ;;
+
+        vfio_device_migration_has_start_pfn)
+            #
+            # Determine if the 'vfio_device_migration_info' structure has
+            # a 'start_pfn' field.
+            #
+            # This member was present in proposed interface for vGPU Migration
+            # ("[PATCH v3 0/5] Add migration support for VFIO device ")
+            # https://lists.gnu.org/archive/html/qemu-devel/2019-02/msg05176.html
+            # which is not present in upstreamed commit a8a24f3f6e38 (vfio: UAPI
+            # for migration interface for device state) in v5.8 (2020-05-29)
+            #
+            CODE="
+            #include <linux/vfio.h>
+            int conftest_vfio_device_migration_has_start_pfn(void) {
+                return offsetof(struct vfio_device_migration_info, start_pfn);
+            }"
+
+            compile_check_conftest "$CODE" "NV_VFIO_DEVICE_MIGRATION_HAS_START_PFN" "" "types"
+        ;;
+
+        drm_available)
+            # Determine if the DRM subsystem is usable
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_DRV_H_PRESENT)
+            #include <drm/drm_drv.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_PRIME_H_PRESENT)
+            #include <drm/drm_prime.h>
+            #endif
+
+            #if !defined(CONFIG_DRM) && !defined(CONFIG_DRM_MODULE)
+            #error DRM not enabled
+            #endif
+
+            void conftest_drm_available(void) {
+                struct drm_driver drv;
+
+                /* 2013-01-15 89177644a7b6306e6084a89eab7e290f4bfef397 */
+                drv.gem_prime_pin = 0;
+                drv.gem_prime_get_sg_table = 0;
+                drv.gem_prime_vmap = 0;
+                drv.gem_prime_vunmap = 0;
+                (void)drm_gem_prime_import;
+                (void)drm_gem_prime_export;
+
+                /* 2013-10-02 1bb72532ac260a2d3982b40bdd4c936d779d0d16 */
+                (void)drm_dev_alloc;
+
+                /* 2013-10-02 c22f0ace1926da399d9a16dfaf09174c1b03594c */
+                (void)drm_dev_register;
+
+                /* 2013-10-02 c3a49737ef7db0bdd4fcf6cf0b7140a883e32b2a */
+                (void)drm_dev_unregister;
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_AVAILABLE" "" "generic"
+        ;;
+
+        drm_dev_unref)
+            #
+            # Determine if drm_dev_unref() is present.
+            # If it isn't, we use drm_dev_free() instead.
+            #
+            # drm_dev_free was added by commit 0dc8fe5985e0 ("drm: introduce
+            # drm_dev_free() to fix error paths") in v3.13 (2013-10-02)
+            #
+            # Renamed to drm_dev_unref by commit 099d1c290e2e
+            # ("drm: provide device-refcount") in v3.15 (2014-01-29)
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+            void conftest_drm_dev_unref(void) {
+                drm_dev_unref();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_DEV_UNREF_PRESENT" "" "functions"
+        ;;
+
+        pde_data)
+            #
+            # Determine if the PDE_DATA() function is present.
+            #
+            # Added by commit d9dda78bad87
+            # ("procfs: new helper - PDE_DATA(inode)") in v3.10
+            #
+            CODE="
+            #include <linux/proc_fs.h>
+            void conftest_PDE_DATA(void) {
+                PDE_DATA();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PDE_DATA_PRESENT" "" "functions"
+        ;;
+
+        get_num_physpages)
+            #
+            # Determine if the get_num_physpages() function is
+            # present.
+            #
+            # Added by commit 7ee3d4e8cd56 ("mm: introduce helper function
+            # mem_init_print_info() to simplify mem_init()") in v3.11
+            #
+            CODE="
+            #include <linux/mm.h>
+            void conftest_get_num_physpages(void) {
+                get_num_physpages(NULL);
+            }"
+
+            compile_check_conftest "$CODE" "NV_GET_NUM_PHYSPAGES_PRESENT" "" "functions"
+        ;;
+
+        proc_remove)
+            #
+            # Determine if the proc_remove() function is present.
+            #
+            # Added by commit a8ca16ea7b0a ("proc: Supply a function to
+            # remove a proc entry by PDE") in v3.10
+            #
+            CODE="
+            #include <linux/proc_fs.h>
+            void conftest_proc_remove(void) {
+                proc_remove();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PROC_REMOVE_PRESENT" "" "functions"
+        ;;
+
+        backing_dev_info)
+            #
+            # Determine if the 'address_space' structure has
+            # a 'backing_dev_info' field.
+            #
+            # Removed by commit b83ae6d42143 ("fs: remove
+            # mapping->backing_dev_info") in v4.0
+            #
+            CODE="
+            #include <linux/fs.h>
+            int conftest_backing_dev_info(void) {
+                return offsetof(struct address_space, backing_dev_info);
+            }"
+
+            compile_check_conftest "$CODE" "NV_ADDRESS_SPACE_HAS_BACKING_DEV_INFO" "" "types"
+        ;;
+
+        address_space)
+            #
+            # Determine if the 'address_space' structure has
+            # a 'tree_lock' field of type rwlock_t.
+            #
+            # 'tree_lock' was changed to spinlock_t by commit 19fd6231279b
+            # ("mm: spinlock tree_lock") in v2.6.27
+            #
+            # It was removed altogether by commit b93b016313b3 ("page cache:
+            # use xa_lock") in v4.17
+            #
+            CODE="
+            #include <linux/fs.h>
+            int conftest_address_space(void) {
+                struct address_space as;
+                rwlock_init(&as.tree_lock);
+                return offsetof(struct address_space, tree_lock);
+            }"
+
+            compile_check_conftest "$CODE" "NV_ADDRESS_SPACE_HAS_RWLOCK_TREE_LOCK" "" "types"
+        ;;
+
+        address_space_init_once)
+            #
+            # Determine if address_space_init_once is present.
+            #
+            # Added by commit 2aa15890f3c1 ("mm: prevent concurrent
+            # unmap_mapping_range() on the same inode") in v2.6.38
+            #
+            # If not present, it will be defined in uvm-linux.h.
+            #
+            CODE="
+            #include <linux/fs.h>
+            void conftest_address_space_init_once(void) {
+                address_space_init_once();
+            }"
+
+            compile_check_conftest "$CODE" "NV_ADDRESS_SPACE_INIT_ONCE_PRESENT" "" "functions"
+        ;;
+
+        kbasename)
+            #
+            # Determine if the kbasename() function is present.
+            #
+            # Added by commit b18888ab256f ("string: introduce helper to get
+            # base file name from given path") in v3.8
+            #
+            # If not present, it will be defined in uvm-linux.h.
+            #
+            CODE="
+            #include <linux/string.h>
+            void conftest_kbasename(void) {
+                kbasename();
+            }"
+
+            compile_check_conftest "$CODE" "NV_KBASENAME_PRESENT" "" "functions"
+        ;;
+
+        kuid_t)
+            #
+            # Determine if the 'kuid_t' type is present.
+            #
+            # Added by commit 7a4e7408c5ca ("userns: Add kuid_t and kgid_t
+            # and associated infrastructure in uidgid.h") in v3.5
+            #
+            CODE="
+            #include <linux/sched.h>
+            kuid_t conftest_kuid_t;
+            "
+
+            compile_check_conftest "$CODE" "NV_KUID_T_PRESENT" "" "types"
+        ;;
+
+        pm_vt_switch_required)
+            #
+            # Determine if the pm_vt_switch_required() function is present.
+            #
+            # Added by commit f43f627d2f17 ("PM: make VT switching to the
+            # suspend console optional v3") in v3.10
+            #
+            CODE="
+            #include <linux/pm.h>
+            void conftest_pm_vt_switch_required(void) {
+                pm_vt_switch_required();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PM_VT_SWITCH_REQUIRED_PRESENT" "" "functions"
+        ;;
+
+        file_inode)
+            #
+            # Determine if the 'file' structure has
+            # a 'f_inode' field.
+            #
+            # Added by commit dd37978c50bc
+            # ("cache the value of file_inode() in struct file") in v3.9
+            #
+            CODE="
+            #include <linux/fs.h>
+            int conftest_file_inode(void) {
+                return offsetof(struct file, f_inode);
+            }"
+
+            compile_check_conftest "$CODE" "NV_FILE_HAS_INODE" "" "types"
+        ;;
+
+        xen_ioemu_inject_msi)
+            # Determine if the xen_ioemu_inject_msi() function is present.
+            CODE="
+            #if defined(NV_XEN_IOEMU_H_PRESENT)
+            #include <linux/kernel.h>
+            #include <xen/interface/xen.h>
+            #include <xen/hvm.h>
+            #include <xen/ioemu.h>
+            #endif
+            void conftest_xen_ioemu_inject_msi(void) {
+                xen_ioemu_inject_msi();
+            }"
+
+            compile_check_conftest "$CODE" "NV_XEN_IOEMU_INJECT_MSI" "" "functions"
+        ;;
+
+        phys_to_dma)
+            #
+            # Determine if the phys_to_dma function is present.
+            # It does not exist on all architectures.
+            #
+            CODE="
+            #include <linux/dma-mapping.h>
+            void conftest_phys_to_dma(void) {
+                phys_to_dma();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PHYS_TO_DMA_PRESENT" "" "functions"
+        ;;
+
+        dma_ops)
+            #
+            # Determine if the 'dma_ops' structure is present.
+            # It does not exist on all architectures.
+            #
+            CODE="
+            #include <linux/dma-mapping.h>
+            void conftest_dma_ops(void) {
+                (void)dma_ops;
+            }"
+
+            compile_check_conftest "$CODE" "NV_DMA_OPS_PRESENT" "" "symbols"
+        ;;
+
+        swiotlb_dma_ops)
+            #
+            # Determine if the 'swiotlb_dma_ops' structure is present.
+            # It does not exist on all architectures.
+            #
+            CODE="
+            #include <linux/dma-mapping.h>
+            void conftest_dma_ops(void) {
+                (void)swiotlb_dma_ops;
+            }"
+
+            compile_check_conftest "$CODE" "NV_SWIOTLB_DMA_OPS_PRESENT" "" "symbols"
+        ;;
+
+        get_dma_ops)
+            #
+            # Determine if the get_dma_ops() function is present.
+            #
+            # The structure was made available to all architectures by commit
+            # e1c7e324539a ("dma-mapping: always provide the dma_map_ops
+            # based implementation") in v4.5
+            #
+            CODE="
+            #include <linux/dma-mapping.h>
+            void conftest_get_dma_ops(void) {
+                get_dma_ops();
+            }"
+
+            compile_check_conftest "$CODE" "NV_GET_DMA_OPS_PRESENT" "" "functions"
+        ;;
+
+        noncoherent_swiotlb_dma_ops)
+            #
+            # Determine if the 'noncoherent_swiotlb_dma_ops' symbol is present.
+            # This API only exists on ARM64.
+            #
+            # Added by commit 7363590d2c46 ("arm64: Implement coherent DMA API
+            # based on swiotlb") in v3.15
+            #
+            # Removed by commit 9d3bfbb4df58 ("arm64: Combine coherent and
+            # non-coherent swiotlb dma_ops") in v4.0
+            #
+            CODE="
+            #include <linux/dma-mapping.h>
+            void conftest_noncoherent_swiotlb_dma_ops(void) {
+                (void)noncoherent_swiotlb_dma_ops;
+            }"
+
+            compile_check_conftest "$CODE" "NV_NONCOHERENT_SWIOTLB_DMA_OPS_PRESENT" "" "symbols"
+        ;;
+
+        dma_map_resource)
+            #
+            # Determine if the dma_map_resource() function is present.
+            #
+            # Added by commit 6f3d87968f9c ("dma-mapping: add
+            # dma_{map,unmap}_resource") in v4.9 (2016-08-10)
+            #
+            CODE="
+            #include <linux/dma-mapping.h>
+            void conftest_dma_map_resource(void) {
+                dma_map_resource();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DMA_MAP_RESOURCE_PRESENT" "" "functions"
+        ;;
+
+        write_cr4)
+            #
+            # Determine if the write_cr4() function is present.
+            #
+            CODE="
+            #include <asm/processor.h>
+            void conftest_write_cr4(void) {
+                write_cr4();
+            }"
+
+            compile_check_conftest "$CODE" "NV_WRITE_CR4_PRESENT" "" "functions"
+        ;;
+
+        of_get_property)
+            #
+            # Determine if the of_get_property function is present.
+            #
+            # Support for kernels without CONFIG_OF defined added by commit
+            # 89272b8c0d42 ("dt: add empty of_get_property for non-dt") in v3.1
+            #
+            # Test if linux/of.h header file inclusion is successful or not and
+            # define/undefine NV_LINUX_OF_H_USABLE depending upon status of inclusion
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/of.h>
+            " > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                echo "#define NV_LINUX_OF_H_USABLE" | append_conftest "generic"
+                CODE="
+                #include <linux/of.h>
+                void conftest_of_get_property() {
+                    of_get_property();
+                }"
+
+                compile_check_conftest "$CODE" "NV_OF_GET_PROPERTY_PRESENT" "" "functions"
+            else
+                echo "#undef NV_LINUX_OF_H_USABLE" | append_conftest "generic"
+                echo "#undef NV_OF_GET_PROPERTY_PRESENT" | append_conftest "functions"
+            fi
+        ;;
+
+        of_find_node_by_phandle)
+            #
+            # Determine if the of_find_node_by_phandle function is present.
+            #
+            # Support for kernels without CONFIG_OF defined added by commit
+            # ce16b9d23561 ("of: define of_find_node_by_phandle for
+            # !CONFIG_OF") in v4.2
+            #
+            # Test if linux/of.h header file inclusion is successful or not and
+            # define/undefine NV_LINUX_OF_H_USABLE depending upon status of inclusion.
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/of.h>
+            " > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                echo "#define NV_LINUX_OF_H_USABLE" | append_conftest "generic"
+                CODE="
+                #include <linux/of.h>
+                void conftest_of_find_node_by_phandle() {
+                    of_find_node_by_phandle();
+                }"
+
+                compile_check_conftest "$CODE" "NV_OF_FIND_NODE_BY_PHANDLE_PRESENT" "" "functions"
+            else
+                echo "#undef NV_LINUX_OF_H_USABLE" | append_conftest "generic"
+                echo "#undef NV_OF_FIND_NODE_BY_PHANDLE_PRESENT" | append_conftest "functions"
+            fi
+        ;;
+
+        of_node_to_nid)
+            #
+            # Determine if of_node_to_nid is present
+            #
+            # Dummy implementation added by commit 559e2b7ee7a1
+            # ("of: Provide default of_node_to_nid() implementation.") in v2.6.36
+            #
+            # Real implementation added by commit 298535c00a2c
+            # ("of, numa: Add NUMA of binding implementation.") in v4.7
+            #
+            # Test if linux/of.h header file inclusion is successful or not and
+            # define/undefine NV_LINUX_OF_H_USABLE depending upon status of inclusion.
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/of.h>
+            " > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                echo "#define NV_LINUX_OF_H_USABLE" | append_conftest "generic"
+                CODE="
+                #include <linux/version.h>
+                #include <linux/utsname.h>
+                #include <linux/of.h>
+                void conftest_of_node_to_nid() {
+                    of_node_to_nid();
+                }"
+
+                compile_check_conftest "$CODE" "NV_OF_NODE_TO_NID_PRESENT" "" "functions"
+            else
+                echo "#undef NV_LINUX_OF_H_USABLE" | append_conftest "generic"
+                echo "#undef NV_OF_NODE_TO_NID_PRESENT" | append_conftest "functions"
+            fi
+        ;;
+
+        pnv_pci_get_npu_dev)
+            #
+            # Determine if the pnv_pci_get_npu_dev function is present.
+            #
+            # Added by commit 5d2aa710e697 ("powerpc/powernv: Add support
+            # for Nvlink NPUs") in v4.5
+            #
+            CODE="
+            #include <linux/pci.h>
+            void conftest_pnv_pci_get_npu_dev() {
+                pnv_pci_get_npu_dev();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PNV_PCI_GET_NPU_DEV_PRESENT" "" "functions"
+        ;;
+
+        node_end_pfn)
+            #
+            # Determine if the node_end_pfn() function is present.
+            #
+            # Made available for all architectures by commit c6830c22603a
+            # ("Fix node_start/end_pfn() definition for mm/page_cgroup.c") in v3.0
+            #
+            CODE="
+            #include <linux/mm.h>
+            void conftest_node_end_pfn() {
+                node_end_pfn();
+            }"
+
+            compile_check_conftest "$CODE" "NV_NODE_END_PFN_PRESENT" "" "functions"
+        ;;
+
+        kernel_write)
+            #
+            # Determine if the function kernel_write() is present.
+            #
+            # First exported by commit 7bb307e894d5 ("export kernel_write(),
+            # convert open-coded instances") in v3.9
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/fs.h>
+            void conftest_kernel_write(void) {
+                kernel_write();
+            }" > conftest$$.c;
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#undef NV_KERNEL_WRITE_PRESENT" | append_conftest "function"
+                rm -f conftest$$.o
+            else
+                echo "#define NV_KERNEL_WRITE_PRESENT" | append_conftest "function"
+
+                #
+                # Determine the pos argument type, which was changed by
+                # commit e13ec939e96b1 (fs: fix kernel_write prototype) on
+                # 9/1/2017.
+                #
+                echo "$CONFTEST_PREAMBLE
+                #include <linux/fs.h>
+                ssize_t kernel_write(struct file *file, const void *buf,
+                                     size_t count, loff_t *pos)
+                {
+                    return 0;
+                }" > conftest$$.c;
+
+                $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+                rm -f conftest$$.c
+
+                if [ -f conftest$$.o ]; then
+                    echo "#define NV_KERNEL_WRITE_HAS_POINTER_POS_ARG" | append_conftest "function"
+                    rm -f conftest$$.o
+                else
+                    echo "#undef NV_KERNEL_WRITE_HAS_POINTER_POS_ARG" | append_conftest "function"
+                fi
+            fi
+        ;;
+
+        kernel_read)
+            #
+            # Determine if the function kernel_read() is present.
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/fs.h>
+            void conftest_kernel_read(void) {
+                kernel_read();
+            }" > conftest$$.c;
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#undef NV_KERNEL_READ_PRESENT" | append_conftest "function"
+                rm -f conftest$$.o
+            else
+                echo "#define NV_KERNEL_READ_PRESENT" | append_conftest "function"
+
+                #
+                # Determine the pos argument type, which was changed by
+                # commit bdd1d2d3d251c (fs: fix kernel_read prototype) on
+                # 9/1/2017.
+                #
+                echo "$CONFTEST_PREAMBLE
+                #include <linux/fs.h>
+                ssize_t kernel_read(struct file *file, void *buf, size_t count,
+                                    loff_t *pos)
+                {
+                    return 0;
+                }" > conftest$$.c;
+
+                $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+                rm -f conftest$$.c
+
+                if [ -f conftest$$.o ]; then
+                    echo "#define NV_KERNEL_READ_HAS_POINTER_POS_ARG" | append_conftest "function"
+                    rm -f conftest$$.o
+                else
+                    echo "#undef NV_KERNEL_READ_HAS_POINTER_POS_ARG" | append_conftest "function"
+                fi
+            fi
+        ;;
+
+        vm_insert_pfn_prot)
+            #
+            # Determine if vm_insert_pfn_prot function is present
+            #
+            # Added by commit 1745cbc5d0de ("mm: Add vm_insert_pfn_prot()") in
+            # v3.16.59
+            #
+            # Removed by commit f5e6d1d5f8f3 ("mm: introduce
+            # vmf_insert_pfn_prot()") in v4.20.
+            #
+            CODE="
+            #include <linux/mm.h>
+            void conftest_vm_insert_pfn_prot() {
+                vm_insert_pfn_prot();
+            }"
+
+            compile_check_conftest "$CODE" "NV_VM_INSERT_PFN_PROT_PRESENT" "" "functions"
+        ;;
+
+        vmf_insert_pfn_prot)
+            #
+            # Determine if vmf_insert_pfn_prot function is present
+            #
+            # Added by commit f5e6d1d5f8f3 ("mm: introduce
+            # vmf_insert_pfn_prot()") in v4.20.
+            #
+            CODE="
+            #include <linux/mm.h>
+            void conftest_vmf_insert_pfn_prot() {
+                vmf_insert_pfn_prot();
+            }"
+
+            compile_check_conftest "$CODE" "NV_VMF_INSERT_PFN_PROT_PRESENT" "" "functions"
+        ;;
+
+        drm_atomic_available)
+            #
+            # Determine if the DRM atomic modesetting subsystem is usable
+            #
+            # Added by commit 036ef5733ba4
+            # ("drm/atomic: Allow drivers to subclass drm_atomic_state, v3") in
+            # v4.2 (2018-05-18).
+            #
+            # Make conftest more robust by adding test for
+            # drm_atomic_set_mode_prop_for_crtc(), this function added by
+            # commit 955f3c334f0f ("drm/atomic: Add MODE_ID property") in v4.2
+            # (2015-05-25). If the DRM atomic modesetting subsystem is
+            # back ported to Linux kernel older than v4.2, then commit
+            # 955f3c334f0f must be back ported in order to get NVIDIA-DRM KMS
+            # support.
+            # Commit 72fdb40c1a4b ("drm: extract drm_atomic_uapi.c") in v4.20
+            # (2018-09-05), moved drm_atomic_set_mode_prop_for_crtc() function
+            # prototype from drm/drm_atomic.h to drm/drm_atomic_uapi.h.
+            #
+            echo "$CONFTEST_PREAMBLE
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+            #include <drm/drm_atomic.h>
+            #if !defined(CONFIG_DRM) && !defined(CONFIG_DRM_MODULE)
+            #error DRM not enabled
+            #endif
+            void conftest_drm_atomic_modeset_available(void) {
+                size_t a;
+
+                a = offsetof(struct drm_mode_config_funcs, atomic_state_alloc);
+            }" > conftest$$.c;
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+
+                echo "$CONFTEST_PREAMBLE
+                #if defined(NV_DRM_DRMP_H_PRESENT)
+                #include <drm/drmP.h>
+                #endif
+                #include <drm/drm_atomic.h>
+                #if defined(NV_DRM_DRM_ATOMIC_UAPI_H_PRESENT)
+                #include <drm/drm_atomic_uapi.h>
+                #endif
+                void conftest_drm_atomic_set_mode_prop_for_crtc(void) {
+                    drm_atomic_set_mode_prop_for_crtc();
+                }" > conftest$$.c;
+
+                $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+                rm -f conftest$$.c
+
+                if [ -f conftest$$.o ]; then
+                    rm -f conftest$$.o
+                    echo "#undef NV_DRM_ATOMIC_MODESET_AVAILABLE" | append_conftest "generic"
+                else
+                    echo "#define NV_DRM_ATOMIC_MODESET_AVAILABLE" | append_conftest "generic"
+                fi
+            else
+                echo "#undef NV_DRM_ATOMIC_MODESET_AVAILABLE" | append_conftest "generic"
+            fi
+        ;;
+
+        drm_bus_present)
+            #
+            # Determine if the 'struct drm_bus' type is present.
+            #
+            # Added by commit 8410ea3b95d1 ("drm: rework PCI/platform driver
+            # interface.") in v2.6.39 (2010-12-15)
+            #
+            # Removed by commit c5786fe5f1c5 ("drm: Goody bye, drm_bus!")
+            # in v3.18 (2014-08-29)
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            void conftest_drm_bus_present(void) {
+                struct drm_bus bus;
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_BUS_PRESENT" "" "types"
+        ;;
+
+        drm_bus_has_bus_type)
+            #
+            # Determine if the 'drm_bus' structure has a 'bus_type' field.
+            #
+            # Added by commit 8410ea3b95d1 ("drm: rework PCI/platform driver
+            # interface.") in v2.6.39 (2010-12-15)
+            #
+            # Removed by commit 42b21049fc26 ("drm: kill drm_bus->bus_type")
+            # in v3.16 (2013-11-03)
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            int conftest_drm_bus_has_bus_type(void) {
+                return offsetof(struct drm_bus, bus_type);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_BUS_HAS_BUS_TYPE" "" "types"
+        ;;
+
+        drm_bus_has_get_irq)
+            #
+            # Determine if the 'drm_bus' structure has a 'get_irq' field.
+            #
+            # Added by commit 8410ea3b95d1 ("drm: rework PCI/platform
+            # driver interface.") in v2.6.39 (2010-12-15)
+            #
+            # Removed by commit b2a21aa25a39 ("drm: remove bus->get_irq
+            # implementations") in v3.16 (2013-11-03)
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            int conftest_drm_bus_has_get_irq(void) {
+                return offsetof(struct drm_bus, get_irq);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_BUS_HAS_GET_IRQ" "" "types"
+        ;;
+
+        drm_bus_has_get_name)
+            #
+            # Determine if the 'drm_bus' structure has a 'get_name' field.
+            #
+            # Added by commit 8410ea3b95d1 ("drm: rework PCI/platform driver
+            # interface.") in v2.6.39 (2010-12-15)
+            #
+            # removed by commit 9de1b51f1fae ("drm: remove drm_bus->get_name")
+            # in v3.16 (2013-11-03)
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            int conftest_drm_bus_has_get_name(void) {
+                return offsetof(struct drm_bus, get_name);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_BUS_HAS_GET_NAME" "" "types"
+        ;;
+
+        drm_driver_has_legacy_dev_list)
+            #
+            # Determine if the 'drm_driver' structure has a 'legacy_dev_list' field.
+            #
+            # Renamed from device_list to legacy_device_list by commit
+            # b3f2333de8e8 ("drm: restrict the device list for shadow
+            # attached drivers") in v3.14 (2013-12-11)
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_DRV_H_PRESENT)
+            #include <drm/drm_drv.h>
+            #endif
+
+            int conftest_drm_driver_has_legacy_dev_list(void) {
+                return offsetof(struct drm_driver, legacy_dev_list);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_DRIVER_HAS_LEGACY_DEV_LIST" "" "types"
+        ;;
+
+        jiffies_to_timespec)
+            #
+            # Determine if jiffies_to_timespec() is present
+            #
+            # removed by commit 751addac78b6
+            # ("y2038: remove obsolete jiffies conversion functions")
+            # in v5.6-rc1 (2019-12-13).
+        CODE="
+        #include <linux/jiffies.h>
+        void conftest_jiffies_to_timespec(void){
+            jiffies_to_timespec();
+        }"
+            compile_check_conftest "$CODE" "NV_JIFFIES_TO_TIMESPEC_PRESENT" "" "functions"
+        ;;
+
+        drm_init_function_args)
+            #
+            # Determine if these functions:
+            #   drm_universal_plane_init()
+            #   drm_crtc_init_with_planes()
+            #   drm_encoder_init()
+            # have a 'name' argument, which was added by these commits:
+            #   drm_universal_plane_init:   2015-12-09  b0b3b7951114315d65398c27648705ca1c322faa
+            #   drm_crtc_init_with_planes:  2015-12-09  f98828769c8838f526703ef180b3088a714af2f9
+            #   drm_encoder_init:           2015-12-09  13a3d91f17a5f7ed2acd275d18b6acfdb131fb15
+            #
+            # Additionally determine whether drm_universal_plane_init() has a
+            # 'format_modifiers' argument, which was added by:
+            #   2017-07-23  e6fc3b68558e4c6d8d160b5daf2511b99afa8814
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_CRTC_H_PRESENT)
+            #include <drm/drm_crtc.h>
+            #endif
+
+            int conftest_drm_crtc_init_with_planes_has_name_arg(void) {
+                return
+                    drm_crtc_init_with_planes(
+                            NULL,  /* struct drm_device *dev */
+                            NULL,  /* struct drm_crtc *crtc */
+                            NULL,  /* struct drm_plane *primary */
+                            NULL,  /* struct drm_plane *cursor */
+                            NULL,  /* const struct drm_crtc_funcs *funcs */
+                            NULL);  /* const char *name */
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_CRTC_INIT_WITH_PLANES_HAS_NAME_ARG" "" "types"
+
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_ENCODER_H_PRESENT)
+            #include <drm/drm_encoder.h>
+            #endif
+
+            int conftest_drm_encoder_init_has_name_arg(void) {
+                return
+                    drm_encoder_init(
+                            NULL,  /* struct drm_device *dev */
+                            NULL,  /* struct drm_encoder *encoder */
+                            NULL,  /* const struct drm_encoder_funcs *funcs */
+                            DRM_MODE_ENCODER_NONE, /* int encoder_type */
+                            NULL); /* const char *name */
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_ENCODER_INIT_HAS_NAME_ARG" "" "types"
+
+            echo "$CONFTEST_PREAMBLE
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_PLANE_H_PRESENT)
+            #include <drm/drm_plane.h>
+            #endif
+
+            int conftest_drm_universal_plane_init_has_format_modifiers_arg(void) {
+                return
+                    drm_universal_plane_init(
+                            NULL,  /* struct drm_device *dev */
+                            NULL,  /* struct drm_plane *plane */
+                            0,     /* unsigned long possible_crtcs */
+                            NULL,  /* const struct drm_plane_funcs *funcs */
+                            NULL,  /* const uint32_t *formats */
+                            0,     /* unsigned int format_count */
+                            NULL,  /* const uint64_t *format_modifiers */
+                            DRM_PLANE_TYPE_PRIMARY,
+                            NULL);  /* const char *name */
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+
+                echo "#define NV_DRM_UNIVERSAL_PLANE_INIT_HAS_FORMAT_MODIFIERS_ARG" | append_conftest "types"
+                echo "#define NV_DRM_UNIVERSAL_PLANE_INIT_HAS_NAME_ARG" | append_conftest "types"
+            else
+                echo "#undef NV_DRM_UNIVERSAL_PLANE_INIT_HAS_FORMAT_MODIFIERS_ARG" | append_conftest "types"
+
+                echo "$CONFTEST_PREAMBLE
+                #if defined(NV_DRM_DRMP_H_PRESENT)
+                #include <drm/drmP.h>
+                #endif
+
+                #if defined(NV_DRM_DRM_PLANE_H_PRESENT)
+                #include <drm/drm_plane.h>
+                #endif
+
+                int conftest_drm_universal_plane_init_has_name_arg(void) {
+                    return
+                        drm_universal_plane_init(
+                                NULL,  /* struct drm_device *dev */
+                                NULL,  /* struct drm_plane *plane */
+                                0,     /* unsigned long possible_crtcs */
+                                NULL,  /* const struct drm_plane_funcs *funcs */
+                                NULL,  /* const uint32_t *formats */
+                                0,     /* unsigned int format_count */
+                                DRM_PLANE_TYPE_PRIMARY,
+                                NULL);  /* const char *name */
+                }" > conftest$$.c
+
+                $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+
+                if [ -f conftest$$.o ]; then
+                    rm -f conftest$$.o
+
+                    echo "#define NV_DRM_UNIVERSAL_PLANE_INIT_HAS_NAME_ARG" | append_conftest "types"
+                else
+                    echo "#undef NV_DRM_UNIVERSAL_PLANE_INIT_HAS_NAME_ARG" | append_conftest "types"
+                fi
+            fi
+
+        ;;
+
+        vzalloc)
+            #
+            # Determine if the vzalloc function is present
+            #
+            # Added by commit e1ca7788dec6 ("mm: add vzalloc() and
+            # vzalloc_node() helpers") in v2.6.37 (2010-10-26)
+            #
+            CODE="
+            #include <linux/vmalloc.h>
+            void conftest_vzalloc() {
+                vzalloc();
+            }"
+
+            compile_check_conftest "$CODE" "NV_VZALLOC_PRESENT" "" "functions"
+        ;;
+
+        drm_driver_has_set_busid)
+            #
+            # Determine if the drm_driver structure has a 'set_busid' callback
+            # field.
+            #
+            # Added by commit 915b4d11b8b9 ("drm: add driver->set_busid()
+            # callback") in v3.18 (2014-08-29)
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            int conftest_drm_driver_has_set_busid(void) {
+                return offsetof(struct drm_driver, set_busid);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_DRIVER_HAS_SET_BUSID" "" "types"
+        ;;
+
+        drm_driver_has_gem_prime_res_obj)
+            #
+            # Determine if the drm_driver structure has a 'gem_prime_res_obj'
+            # callback field.
+            #
+            # Added by commit 3aac4502fd3f ("dma-buf: use reservation
+            # objects") in v3.17 (2014-07-01).
+            #
+            # Removed by commit 51c98747113e (drm/prime: Ditch
+            # gem_prime_res_obj hook) in v5.4.
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            int conftest_drm_driver_has_gem_prime_res_obj(void) {
+                return offsetof(struct drm_driver, gem_prime_res_obj);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_DRIVER_HAS_GEM_PRIME_RES_OBJ" "" "types"
+        ;;
+
+        drm_crtc_state_has_connectors_changed)
+            #
+            # Determine if the crtc_state has a 'connectors_changed' field.
+            #
+            # Added by commit fc596660dd4e ("drm/atomic: add
+            # connectors_changed to separate it from mode_changed, v2")
+            # in v4.3 (2015-07-21)
+            #
+            CODE="
+            #include <drm/drm_crtc.h>
+            void conftest_drm_crtc_state_has_connectors_changed(void) {
+                struct drm_crtc_state foo;
+                (void)foo.connectors_changed;
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_CRTC_STATE_HAS_CONNECTORS_CHANGED" "" "types"
+        ;;
+
+        drm_reinit_primary_mode_group)
+            #
+            # Determine if the function drm_reinit_primary_mode_group() is
+            # present.
+            #
+            # Added by commit 2390cd11bfbe ("drm/crtc: add interface to
+            # reinitialise the legacy mode group") in v3.17 (2014-06-05)
+            #
+            # Removed by commit 3fdefa399e46 ("drm: gc now dead
+            # mode_group code") in v4.3 (2015-07-09)
+            #
+            CODE="
+            #if defined(NV_DRM_DRM_CRTC_H_PRESENT)
+            #include <drm/drm_crtc.h>
+            #endif
+            void conftest_drm_reinit_primary_mode_group(void) {
+                drm_reinit_primary_mode_group();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_REINIT_PRIMARY_MODE_GROUP_PRESENT" "" "functions"
+        ;;
+
+        wait_on_bit_lock_argument_count)
+            #
+            # Determine how many arguments wait_on_bit_lock takes.
+            #
+            # Changed by commit 743162013d40 ("sched: Remove proliferation
+            # of wait_on_bit() action functions") in v3.17 (2014-07-07)
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/wait.h>
+            void conftest_wait_on_bit_lock(void) {
+                wait_on_bit_lock(NULL, 0, 0);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                echo "#define NV_WAIT_ON_BIT_LOCK_ARGUMENT_COUNT 3" | append_conftest "functions"
+                return
+            fi
+
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/wait.h>
+            void conftest_wait_on_bit_lock(void) {
+                wait_on_bit_lock(NULL, 0, NULL, 0);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                echo "#define NV_WAIT_ON_BIT_LOCK_ARGUMENT_COUNT 4" | append_conftest "functions"
+                return
+            fi
+            echo "#error wait_on_bit_lock() conftest failed!" | append_conftest "functions"
+        ;;
+
+        bitmap_clear)
+            #
+            # Determine if the bitmap_clear function is present
+            #
+            # Added by commit c1a2a962a2ad ("bitmap: introduce bitmap_set,
+            # bitmap_clear, bitmap_find_next_zero_area") in v2.6.33
+            # (2009-12-15)
+            #
+            CODE="
+            #include <linux/bitmap.h>
+            void conftest_bitmap_clear() {
+                bitmap_clear();
+            }"
+
+            compile_check_conftest "$CODE" "NV_BITMAP_CLEAR_PRESENT" "" "functions"
+        ;;
+
+        pci_stop_and_remove_bus_device)
+            #
+            # Determine if the pci_stop_and_remove_bus_device() function is present.
+            #
+            # Added by commit 210647af897a ("PCI: Rename pci_remove_bus_device
+            # to pci_stop_and_remove_bus_device") in v3.4 (2012-02-25)
+            #
+            CODE="
+            #include <linux/types.h>
+            #include <linux/pci.h>
+            void conftest_pci_stop_and_remove_bus_device() {
+                pci_stop_and_remove_bus_device();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PCI_STOP_AND_REMOVE_BUS_DEVICE_PRESENT" "" "functions"
+        ;;
+
+        pci_remove_bus_device)
+            #
+            # Determine if the pci_remove_bus_device() function is present.
+            # Added before Linux-2.6.12-rc2 2005-04-16
+            # Because we support builds on non-PCI platforms, we still need
+            # to check for this function's presence.
+            #
+            CODE="
+            #include <linux/types.h>
+            #include <linux/pci.h>
+            void conftest_pci_remove_bus_device() {
+                pci_remove_bus_device();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PCI_REMOVE_BUS_DEVICE_PRESENT" "" "functions"
+        ;;
+
+        drm_helper_mode_fill_fb_struct | drm_helper_mode_fill_fb_struct_has_const_mode_cmd_arg)
+            #
+            # Determine if the drm_helper_mode_fill_fb_struct function takes
+            # 'dev' argument.
+            #
+            # The drm_helper_mode_fill_fb_struct() has been updated to
+            # take 'dev' parameter by commit a3f913ca9892 ("drm: Pass 'dev'
+            # to drm_helper_mode_fill_fb_struct()") in v4.11 (2016-12-14)
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <drm/drm_crtc_helper.h>
+            void drm_helper_mode_fill_fb_struct(struct drm_device *dev,
+                                                struct drm_framebuffer *fb,
+                                                const struct drm_mode_fb_cmd2 *mode_cmd)
+            {
+                return;
+            }" > conftest$$.c;
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_DRM_HELPER_MODE_FILL_FB_STRUCT_HAS_DEV_ARG" | append_conftest "function"
+                echo "#define NV_DRM_HELPER_MODE_FILL_FB_STRUCT_HAS_CONST_MODE_CMD_ARG" | append_conftest "function"
+                rm -f conftest$$.o
+            else
+                echo "#undef NV_DRM_HELPER_MODE_FILL_FB_STRUCT_HAS_DEV_ARG" | append_conftest "function"
+
+                #
+                # Determine if the drm_mode_fb_cmd2 pointer argument is const in
+                # drm_mode_config_funcs::fb_create and drm_helper_mode_fill_fb_struct().
+                #
+                # The drm_mode_fb_cmd2 pointer through this call chain was made
+                # const by commit 1eb83451ba55 ("drm: Pass the user drm_mode_fb_cmd2
+                # as const to .fb_create()") in v4.5 (2015-11-11)
+                #
+                echo "$CONFTEST_PREAMBLE
+                #include <drm/drm_crtc_helper.h>
+                void drm_helper_mode_fill_fb_struct(struct drm_framebuffer *fb,
+                                                    const struct drm_mode_fb_cmd2 *mode_cmd)
+                {
+                    return;
+                }" > conftest$$.c;
+
+                $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+                rm -f conftest$$.c
+
+                if [ -f conftest$$.o ]; then
+                    echo "#define NV_DRM_HELPER_MODE_FILL_FB_STRUCT_HAS_CONST_MODE_CMD_ARG" | append_conftest "function"
+                    rm -f conftest$$.o
+                else
+                    echo "#undef NV_DRM_HELPER_MODE_FILL_FB_STRUCT_HAS_CONST_MODE_CMD_ARG" | append_conftest "function"
+                fi
+            fi
+        ;;
+
+        mm_context_t)
+            #
+            # Determine if the 'mm_context_t' data type is present
+            # and if it has an 'id' member.
+            # It does not exist on all architectures.
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            int conftest_mm_context_t(void) {
+                return offsetof(mm_context_t, id);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_MM_CONTEXT_T_HAS_ID" | append_conftest "types"
+                rm -f conftest$$.o
+                return
+            else
+                echo "#undef NV_MM_CONTEXT_T_HAS_ID" | append_conftest "types"
+                return
+            fi
+        ;;
+        get_user_pages)
+            #
+            # Conftest for get_user_pages()
+            #
+            # Use long type for get_user_pages and unsigned long for nr_pages
+            # by commit 28a35716d317 ("mm: use long type for page counts
+            # in mm_populate() and get_user_pages()") in v3.9 (2013-02-22)
+            #
+            # Removed struct task_struct *tsk & struct mm_struct *mm from
+            # get_user_pages by commit cde70140fed8 ("mm/gup: Overload
+            # get_user_pages() functions") in v4.6 (2016-02-12)
+            #
+            # Replaced get_user_pages6 with get_user_pages by commit
+            # c12d2da56d0e ("mm/gup: Remove the macro overload API migration
+            # helpers from the get_user*() APIs") in v4.6 (2016-04-04)
+            #
+            # Replaced write and force parameters with gup_flags by
+            # commit 768ae309a961 ("mm: replace get_user_pages() write/force
+            # parameters with gup_flags") in v4.9 (2016-10-13)
+            #
+            # linux-4.4.168 cherry-picked commit 768ae309a961 without
+            # c12d2da56d0e which is covered in Conftest #3.
+            #
+            # Conftest #1: Check if get_user_pages accepts 6 arguments.
+            # Return if true.
+            # Fall through to conftest #2 on failure.
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            long get_user_pages(unsigned long start,
+                                unsigned long nr_pages,
+                                int write,
+                                int force,
+                                struct page **pages,
+                                struct vm_area_struct **vmas) {
+                return 0;
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_GET_USER_PAGES_HAS_WRITE_AND_FORCE_ARGS" | append_conftest "functions"
+                echo "#undef NV_GET_USER_PAGES_HAS_TASK_STRUCT" | append_conftest "functions"
+                rm -f conftest$$.o
+                return
+            fi
+
+            # Conftest #2: Check if get_user_pages has gup_flags instead of
+            # write and force parameters. And that gup doesn't accept a
+            # task_struct and mm_struct as its first arguments.
+            # Return if available.
+            # Fall through to conftest #3 on failure.
+
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            long get_user_pages(unsigned long start,
+                                unsigned long nr_pages,
+                                unsigned int gup_flags,
+                                struct page **pages,
+                                struct vm_area_struct **vmas) {
+                return 0;
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#undef NV_GET_USER_PAGES_HAS_WRITE_AND_FORCE_ARGS" | append_conftest "functions"
+                echo "#undef NV_GET_USER_PAGES_HAS_TASK_STRUCT" | append_conftest "functions"
+                rm -f conftest$$.o
+                return
+            fi
+
+            # Conftest #3: Check if get_user_pages has gup_flags instead of
+            # write and force parameters AND that gup has task_struct and
+            # mm_struct as its first arguments.
+            # Return if available.
+            # Fall through to default case if absent.
+
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            long get_user_pages(struct task_struct *tsk,
+                                struct mm_struct *mm,
+                                unsigned long start,
+                                unsigned long nr_pages,
+                                unsigned int gup_flags,
+                                struct page **pages,
+                                struct vm_area_struct **vmas) {
+                return 0;
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#undef NV_GET_USER_PAGES_HAS_WRITE_AND_FORCE_ARGS" | append_conftest "functions"
+                echo "#define NV_GET_USER_PAGES_HAS_TASK_STRUCT" | append_conftest "functions"
+                rm -f conftest$$.o
+                return
+            fi
+
+            echo "#define NV_GET_USER_PAGES_HAS_WRITE_AND_FORCE_ARGS" | append_conftest "functions"
+            echo "#define NV_GET_USER_PAGES_HAS_TASK_STRUCT" | append_conftest "functions"
+
+            return
+        ;;
+
+        get_user_pages_remote)
+            #
+            # Determine if the function get_user_pages_remote() is
+            # present and has write/force parameters.
+            #
+            # get_user_pages_remote() was added by commit 1e9877902dc7
+            # ("mm/gup: Introduce get_user_pages_remote()") in v4.6 (2016-02-12)
+            #
+            # get_user_pages[_remote]() write/force parameters
+            # replaced with gup_flags by commits 768ae309a961 ("mm: replace
+            # get_user_pages() write/force parameters with gup_flags") and
+            # commit 9beae1ea8930 ("mm: replace get_user_pages_remote()
+            # write/force parameters with gup_flags") in v4.9 (2016-10-13)
+            #
+            # get_user_pages_remote() added 'locked' parameter by
+            # commit 5b56d49fc31d ("mm: add locked parameter to
+            # get_user_pages_remote()") in v4.10 (2016-12-14)
+            #
+            # conftest #1: check if get_user_pages_remote() is available
+            # return if not available.
+            # Fall through to conftest #2 if it is present
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            void conftest_get_user_pages_remote(void) {
+                get_user_pages_remote();
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#undef NV_GET_USER_PAGES_REMOTE_PRESENT" | append_conftest "functions"
+                echo "#undef NV_GET_USER_PAGES_REMOTE_HAS_WRITE_AND_FORCE_ARGS" | append_conftest "functions"
+                echo "#undef NV_GET_USER_PAGES_REMOTE_HAS_LOCKED_ARG" | append_conftest "functions"
+                rm -f conftest$$.o
+                return
+            fi
+
+            #
+            # conftest #2: check if get_user_pages_remote() has write and
+            # force arguments. Return if these arguments are present
+            # Fall through to conftest #3 if these args are absent.
+            #
+            echo "#define NV_GET_USER_PAGES_REMOTE_PRESENT" | append_conftest "functions"
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            long get_user_pages_remote(struct task_struct *tsk,
+                                       struct mm_struct *mm,
+                                       unsigned long start,
+                                       unsigned long nr_pages,
+                                       int write,
+                                       int force,
+                                       struct page **pages,
+                                       struct vm_area_struct **vmas) {
+                return 0;
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_GET_USER_PAGES_REMOTE_HAS_WRITE_AND_FORCE_ARGS" | append_conftest "functions"
+                echo "#undef NV_GET_USER_PAGES_REMOTE_HAS_LOCKED_ARG" | append_conftest "functions"
+                rm -f conftest$$.o
+                return
+            fi
+
+            # conftest #3: check if get_user_pages_remote() has locked argument
+
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            long get_user_pages_remote(struct task_struct *tsk,
+                                       struct mm_struct *mm,
+                                       unsigned long start,
+                                       unsigned long nr_pages,
+                                       unsigned int gup_flags,
+                                       struct page **pages,
+                                       struct vm_area_struct **vmas,
+                                       int *locked) {
+                return 0;
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_GET_USER_PAGES_REMOTE_HAS_LOCKED_ARG" | append_conftest "functions"
+                rm -f conftest$$.o
+            else
+                echo "#undef NV_GET_USER_PAGES_REMOTE_HAS_LOCKED_ARG" | append_conftest "functions"
+            fi
+            echo "#undef NV_GET_USER_PAGES_REMOTE_HAS_WRITE_AND_FORCE_ARGS" | append_conftest "functions"
+
+        ;;
+
+        usleep_range)
+            #
+            # Determine if the function usleep_range() is present.
+            #
+            # Added by commit 5e7f5a178bba ("timer: Added usleep_range timer")
+            # in v2.6.36 (2010-08-04)
+            #
+            CODE="
+            #include <linux/delay.h>
+            void conftest_usleep_range(void) {
+                usleep_range();
+            }"
+
+            compile_check_conftest "$CODE" "NV_USLEEP_RANGE_PRESENT" "" "functions"
+        ;;
+
+        radix_tree_empty)
+            #
+            # Determine if the function radix_tree_empty() is present.
+            #
+            # Added by commit e9256efcc8e3 ("radix-tree: introduce
+            # radix_tree_empty") in v4.7 (2016-05-20)
+            #
+            CODE="
+            #include <linux/radix-tree.h>
+            int conftest_radix_tree_empty(void) {
+                radix_tree_empty();
+            }"
+
+            compile_check_conftest "$CODE" "NV_RADIX_TREE_EMPTY_PRESENT" "" "functions"
+        ;;
+
+        drm_gem_object_lookup)
+            #
+            # Determine the number of arguments of drm_gem_object_lookup().
+            #
+            # First argument of type drm_device removed by commit
+            # a8ad0bd84f98 ("drm: Remove unused drm_device from
+            # drm_gem_object_lookup()") in v4.7 (2016-05-09)
+            #
+            echo "$CONFTEST_PREAMBLE
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+            #if defined(NV_DRM_DRM_GEM_H_PRESENT)
+            #include <drm/drm_gem.h>
+            #endif
+            void conftest_drm_gem_object_lookup(void) {
+                drm_gem_object_lookup(NULL, NULL, 0);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_DRM_GEM_OBJECT_LOOKUP_ARGUMENT_COUNT 3" | append_conftest "functions"
+                rm -f conftest$$.o
+                return
+            else
+                echo "#define NV_DRM_GEM_OBJECT_LOOKUP_ARGUMENT_COUNT 2" | append_conftest "functions"
+            fi
+        ;;
+
+        drm_master_drop_has_from_release_arg)
+            #
+            # Determine if drm_driver::master_drop() has 'from_release' argument.
+            #
+            # Last argument 'bool from_release' has been removed by commit
+            # d6ed682eba54 ("drm: Refactor drop/set master code a bit")
+            # in v4.8 (2016-06-21)
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            void conftest_drm_master_drop_has_from_release_arg(struct drm_driver *drv) {
+                drv->master_drop(NULL, NULL, false);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_MASTER_DROP_HAS_FROM_RELEASE_ARG" "" "types"
+        ;;
+
+        drm_atomic_state_ref_counting)
+            #
+            # Determine if functions drm_atomic_state_get/put() are
+            # present.
+            #
+            # Added by commit 0853695c3ba4 ("drm: Add reference counting to
+            # drm_atomic_state") in v4.10 (2016-10-14)
+            #
+            CODE="
+            #if defined(NV_DRM_DRM_ATOMIC_H_PRESENT)
+            #include <drm/drm_atomic.h>
+            #endif
+            void conftest_drm_atomic_state_get(void) {
+                drm_atomic_state_get();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_ATOMIC_STATE_REF_COUNTING_PRESENT" "" "functions"
+        ;;
+
+        vm_ops_fault_removed_vma_arg)
+            #
+            # Determine if vma.vm_ops.fault takes (vma, vmf), or just (vmf)
+            # args. Acronym key:
+            #   vma: struct vm_area_struct
+            #   vm_ops: struct vm_operations_struct
+            #   vmf: struct vm_fault
+            #
+            # The redundant vma arg was removed from BOTH vma.vm_ops.fault and
+            # vma.vm_ops.page_mkwrite by commit 11bac8000449 ("mm, fs: reduce
+            # fault, page_mkwrite, and pfn_mkwrite to take only vmf") in
+            # v4.11 (2017-02-24)
+            #
+            CODE="
+            #include <linux/mm.h>
+            void conftest_vm_ops_fault_removed_vma_arg(void) {
+                struct vm_operations_struct vm_ops;
+                struct vm_fault *vmf;
+                (void)vm_ops.fault(vmf);
+            }"
+
+            compile_check_conftest "$CODE" "NV_VM_OPS_FAULT_REMOVED_VMA_ARG" "" "types"
+        ;;
+
+        pnv_npu2_init_context)
+            #
+            # Determine if the pnv_npu2_init_context() function is
+            # present and the signature of its callback.
+            #
+            # Added by commit 1ab66d1fbada ("powerpc/powernv: Introduce
+            # address translation services for Nvlink2") in v4.12
+            # (2017-04-03).
+            #
+            echo "$CONFTEST_PREAMBLE
+            #if defined(NV_ASM_POWERNV_H_PRESENT)
+            #include <linux/pci.h>
+            #include <asm/powernv.h>
+            #endif
+            void conftest_pnv_npu2_init_context(void) {
+                pnv_npu2_init_context();
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+            if [ -f conftest$$.o ]; then
+                echo "#undef NV_PNV_NPU2_INIT_CONTEXT_PRESENT" | append_conftest "functions"
+                echo "#undef NV_PNV_NPU2_INIT_CONTEXT_CALLBACK_RETURNS_VOID" | append_conftest "functions"
+                rm -f conftest$$.o
+                return
+            fi
+
+            echo "#define NV_PNV_NPU2_INIT_CONTEXT_PRESENT" | append_conftest "functions"
+
+            # Check the callback signature
+            echo "$CONFTEST_PREAMBLE
+            #if defined(NV_ASM_POWERNV_H_PRESENT)
+            #include <linux/pci.h>
+            #include <asm/powernv.h>
+            #endif
+
+            struct npu_context *pnv_npu2_init_context(struct pci_dev *gpdev,
+                unsigned long flags,
+                void (*cb)(struct npu_context *, void *),
+                void *priv) {
+                return NULL;
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_PNV_NPU2_INIT_CONTEXT_CALLBACK_RETURNS_VOID" | append_conftest "functions"
+                rm -f conftest$$.o
+                return
+            fi
+
+            echo "#undef NV_PNV_NPU2_INIT_CONTEXT_CALLBACK_RETURNS_VOID" | append_conftest "functions"
+        ;;
+
+        of_get_ibm_chip_id)
+            #
+            # Determine if the of_get_ibm_chip_id() function is present.
+            #
+            # Added by commit b130e7c04f11 ("powerpc: export
+            # of_get_ibm_chip_id function") in v4.2 (2015-05-07)
+            #
+            CODE="
+            #include <linux/version.h>
+            #if defined(NV_ASM_PROM_H_PRESENT)
+            #include <asm/prom.h>
+            #endif
+            void conftest_of_get_ibm_chip_id(void) {
+                #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
+                of_get_ibm_chip_id();
+                #endif
+            }"
+
+            compile_check_conftest "$CODE" "NV_OF_GET_IBM_CHIP_ID_PRESENT" "" "functions"
+        ;;
+
+        drm_driver_unload_has_int_return_type)
+            #
+            # Determine if drm_driver::unload() returns integer value
+            #
+            # Changed to void by commit 11b3c20bdd15 ("drm: Change the return
+            # type of the unload hook to void") in v4.11 (2017-01-06)
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            int conftest_drm_driver_unload_has_int_return_type(struct drm_driver *drv) {
+                return drv->unload(NULL /* dev */);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_DRIVER_UNLOAD_HAS_INT_RETURN_TYPE" "" "types"
+        ;;
+
+        is_export_symbol_present_*)
+            export_symbol_present_conftest $(echo $1 | cut -f5- -d_)
+        ;;
+
+        is_export_symbol_gpl_*)
+            export_symbol_gpl_conftest $(echo $1 | cut -f5- -d_)
+        ;;
+
+        drm_atomic_helper_crtc_destroy_state_has_crtc_arg)
+            #
+            # Determine if __drm_atomic_helper_crtc_destroy_state() has 'crtc'
+            # argument.
+            #
+            # 'crtc' argument removed by commit ec2dc6a0fe38 ("drm: Drop crtc
+            # argument from __drm_atomic_helper_crtc_destroy_state") in v4.7
+            # (2016-05-09)
+            #
+            CODE="
+            #if defined(NV_DRM_DRM_ATOMIC_HELPER_H_PRESENT)
+            #include <drm/drm_atomic_helper.h>
+            #endif
+            void conftest_drm_atomic_helper_crtc_destroy_state_has_crtc_arg(void) {
+                __drm_atomic_helper_crtc_destroy_state(NULL, NULL);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_ATOMIC_HELPER_CRTC_DESTROY_STATE_HAS_CRTC_ARG" "" "types"
+        ;;
+
+        drm_crtc_helper_funcs_has_atomic_enable)
+            #
+            # Determine if struct drm_crtc_helper_funcs has an 'atomic_enable'
+            # member.
+            #
+            # The "enable" callback was renamed to "atomic_enable" by commit
+            # 0b20a0f8c3cb ("drm: Add old state pointer to CRTC .enable()
+            # helper function") in v4.14 (2017-06-30).
+            #
+            CODE="
+            #include <drm/drm_modeset_helper_vtables.h>
+            void conftest_drm_crtc_helper_funcs_has_atomic_enable(void) {
+                struct drm_crtc_helper_funcs funcs;
+                funcs.atomic_enable = NULL;
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_CRTC_HELPER_FUNCS_HAS_ATOMIC_ENABLE" "" "types"
+        ;;
+
+        drm_atomic_helper_connector_dpms)
+            #
+            # Determine if the function drm_atomic_helper_connector_dpms() is present.
+            #
+            # Removed by commit 7d902c05b480 ("drm: Nuke
+            # drm_atomic_helper_connector_dpms") in v4.14 (2017-07-25)
+            #
+            CODE="
+            #if defined(NV_DRM_DRM_ATOMIC_HELPER_H_PRESENT)
+            #include <drm/drm_atomic_helper.h>
+            #endif
+            void conftest_drm_atomic_helper_connector_dpms(void) {
+                drm_atomic_helper_connector_dpms();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_ATOMIC_HELPER_CONNECTOR_DPMS_PRESENT" "" "functions"
+        ;;
+
+        backlight_device_register)
+            #
+            # Determine if the backlight_device_register() function is present
+            # and how many arguments it takes.
+            #
+            # Don't try to support the 4-argument form of backlight_device_register().
+            # The fifth argument was added by commit a19a6ee6cad2
+            # ("backlight: Allow properties to be passed at registration") in
+            # v2.6.34
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/backlight.h>
+            #if !defined(CONFIG_BACKLIGHT_CLASS_DEVICE)
+            #error Backlight class device not enabled
+            #endif
+            void conftest_backlight_device_register(void) {
+                backlight_device_register(NULL, NULL, NULL, NULL, NULL);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                echo "#define NV_BACKLIGHT_DEVICE_REGISTER_PRESENT" | append_conftest "functions"
+                return
+            else
+                echo "#undef NV_BACKLIGHT_DEVICE_REGISTER_PRESENT" | append_conftest "functions"
+                return
+            fi
+        ;;
+
+        backlight_properties_type)
+            #
+            # Determine if the backlight_properties structure has a 'type' field
+            # and whether BACKLIGHT_RAW is defined.
+            #
+            # 'type' field and BACKLIGHT_RAW added by commit bb7ca747f8d6
+            # ("backlight: add backlight type") in v2.6.39
+            #
+            CODE="
+            #include <linux/backlight.h>
+            void conftest_backlight_props_type(void) {
+                struct backlight_properties tmp;
+                tmp.type = BACKLIGHT_RAW;
+            }"
+
+            compile_check_conftest "$CODE" "NV_BACKLIGHT_PROPERTIES_TYPE_PRESENT" "" "types"
+        ;;
+
+        timer_setup)
+            #
+            # Determine if the function timer_setup() is present.
+            #
+            # Added by commit 686fef928bba ("timer: Prepare to change timer
+            # callback argument type") in v4.14 (2017-09-28)
+            #
+            CODE="
+            #include <linux/timer.h>
+            int conftest_timer_setup(void) {
+                return timer_setup();
+            }"
+            compile_check_conftest "$CODE" "NV_TIMER_SETUP_PRESENT" "" "functions"
+        ;;
+
+        radix_tree_replace_slot)
+            #
+            # Determine if the radix_tree_replace_slot() function is
+            # present and how many arguments it takes.
+            #
+            # root parameter added to radix_tree_replace_slot (but the symbol
+            # was not exported) by commit 6d75f366b924 ("lib: radix-tree:
+            # check accounting of existing slot replacement users") in v4.10
+            # (2016-12-12)
+            #
+            # radix_tree_replace_slot symbol export added by commit
+            # 10257d719686 ("EXPORT_SYMBOL radix_tree_replace_slot") in v4.11
+            # (2017-01-11)
+            #
+            CODE="
+            #include <linux/radix-tree.h>
+            #include <linux/version.h>
+            void conftest_radix_tree_replace_slot(void) {
+            #if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)) || (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0))
+                radix_tree_replace_slot();
+            #endif
+            }"
+            compile_check_conftest "$CODE" "NV_RADIX_TREE_REPLACE_SLOT_PRESENT" "" "functions"
+
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/radix-tree.h>
+            void conftest_radix_tree_replace_slot(void) {
+                radix_tree_replace_slot(NULL, NULL);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                echo "#define NV_RADIX_TREE_REPLACE_SLOT_ARGUMENT_COUNT 2" | append_conftest "functions"
+                return
+            fi
+
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/radix-tree.h>
+            void conftest_radix_tree_replace_slot(void) {
+                radix_tree_replace_slot(NULL, NULL, NULL);
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                echo "#define NV_RADIX_TREE_REPLACE_SLOT_ARGUMENT_COUNT 3" | append_conftest "functions"
+                return
+            else
+                echo "#error radix_tree_replace_slot() conftest failed!" | append_conftest "functions"
+            fi
+        ;;
+
+        kthread_create_on_node)
+            #
+            # Determine if kthread_create_on_node is available
+            #
+            # kthread_create_on_node was added in by commit 207205a2ba26
+            # ("kthread: NUMA aware kthread_create_on_node()") in v2.6.39
+            # (2011-03-22).
+            #
+            CODE="
+            #include <linux/kthread.h>
+            void kthread_create_on_node_conftest(void) {
+                 (void)kthread_create_on_node();
+            }"
+
+            compile_check_conftest "$CODE" "NV_KTHREAD_CREATE_ON_NODE_PRESENT" "" "functions"
+        ;;
+
+        cpumask_of_node)
+            #
+            # Determine whether cpumask_of_node is available.
+            #
+            # ARM support for cpumask_of_node() lagged until commit 1a2db300348b
+            # ("arm64, numa: Add NUMA support for arm64 platforms.") in v4.7
+            # (2016-04-08)
+            #
+            CODE="
+            #include    <asm/topology.h>
+            void conftest_cpumask_of_node(void) {
+            (void)cpumask_of_node();
+            }"
+
+            compile_check_conftest "$CODE" "NV_CPUMASK_OF_NODE_PRESENT" "" "functions"
+        ;;
+
+        drm_mode_object_find_has_file_priv_arg)
+            #
+            # Determine if drm_mode_object_find() has 'file_priv' arguments.
+            #
+            # Updated to take 'file_priv' argument by commit 418da17214ac
+            # ("drm: Pass struct drm_file * to __drm_mode_object_find [v2]")
+            # in v4.15 (2017-03-14)
+            #
+            CODE="
+            #include <drm/drm_mode_object.h>
+            void conftest_drm_mode_object_find_has_file_priv_arg(
+                    struct drm_device *dev,
+                    struct drm_file *file_priv,
+                    uint32_t id,
+                    uint32_t type) {
+                (void)drm_mode_object_find(dev, file_priv, id, type);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_MODE_OBJECT_FIND_HAS_FILE_PRIV_ARG" | append_conftest "types"
+        ;;
+
+        pci_enable_msix_range)
+            #
+            # Determine if the pci_enable_msix_range() function is present.
+            #
+            # Added by commit 302a2523c277 ("PCI/MSI: Add
+            # pci_enable_msi_range() and pci_enable_msix_range()") in v3.14
+            # (2013-12-30)
+            #
+            CODE="
+            #include <linux/pci.h>
+            void conftest_pci_enable_msix_range(void) {
+                pci_enable_msix_range();
+            }"
+
+            compile_check_conftest "$CODE" "NV_PCI_ENABLE_MSIX_RANGE_PRESENT" "" "functions"
+        ;;
+
+        dma_buf_owner)
+            #
+            # Determine if the dma_buf struct has an owner member.
+            #
+            # Added by commit 9abdffe286c1 ("dma-buf: add ref counting for
+            # module as exporter") in v4.2 (2015-05-05)
+            #
+            CODE="
+            #include <linux/dma-buf.h>
+            int conftest_dma_buf_owner(void) {
+                return offsetof(struct dma_buf, owner);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DMA_BUF_OWNER_PRESENT" "" "types"
+        ;;
+
+        drm_connector_funcs_have_mode_in_name)
+            #
+            # Determine if _mode_ is present in connector function names.  We
+            # only test drm_mode_connector_attach_encoder() and assume the
+            # other functions are changed in sync.
+            #
+            # drm_mode_connector_attach_encoder() was renamed to
+            # drm_connector_attach_encoder() by commit cde4c44d8769 ("drm:
+            # drop _mode_ from drm_mode_connector_attach_encoder") in v4.19
+            # (2018-07-09)
+            #
+            # drm_mode_connector_update_edid_property() was renamed by commit
+            # c555f02371c3 ("drm: drop _mode_ from update_edit_property()")
+            # in v4.19 (2018-07-09).
+            #
+            # The other DRM functions were renamed by commit 97e14fbeb53f
+            # ("drm: drop _mode_ from remaining connector functions") in v4.19
+            # (2018-07-09)
+            #
+            # Note that drm_connector.h by introduced by commit 522171951761
+            # ("drm: Extract drm_connector.[hc]") in v4.9 (2016-08-12)
+            #
+            CODE="
+            #include <drm/drm_connector.h>
+            void conftest_drm_connector_funcs_have_mode_in_name(void) {
+                drm_mode_connector_attach_encoder();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_CONNECTOR_FUNCS_HAVE_MODE_IN_NAME" "" "functions"
+        ;;
+
+
+        node_states_n_memory)
+            #
+            # Determine if the N_MEMORY constant exists.
+            #
+            # Added by commit 8219fc48adb3 ("mm: node_states: introduce
+            # N_MEMORY") in v3.8 (2012-12-12).
+            #
+            CODE="
+            #include <linux/nodemask.h>
+            int conftest_node_states_n_memory(void) {
+                return N_MEMORY;
+            }"
+
+            compile_check_conftest "$CODE" "NV_NODE_STATES_N_MEMORY_PRESENT" "" "types"
+        ;;
+
+        vm_fault_t)
+            #
+            # Determine if vm_fault_t is present
+            #
+            # Added by commit 1c8f422059ae5da07db7406ab916203f9417e396 ("mm:
+            # change return type to vm_fault_t") in v4.17 (2018-04-05)
+            #
+            CODE="
+            #include <linux/mm.h>
+            vm_fault_t conftest_vm_fault_t;
+            "
+            compile_check_conftest "$CODE" "NV_VM_FAULT_T_IS_PRESENT" "" "types"
+        ;;
+
+        vmf_insert_pfn)
+            #
+            # Determine if the function vmf_insert_pfn() is
+            # present.
+            #
+            # Added by commit 1c8f422059ae5da07db7406ab916203f9417e396 ("mm:
+            # change return type to vm_fault_t") in v4.17 (2018-04-05)
+            #
+            CODE="
+            #include <linux/mm.h>
+            void conftest_vmf_insert_pfn(void) {
+                vmf_insert_pfn();
+            }"
+
+            compile_check_conftest "$CODE" "NV_VMF_INSERT_PFN_PRESENT" "" "functions"
+        ;;
+
+        do_gettimeofday)
+            #
+            # Determine if the function do_gettimeofday() is
+            # present.
+            #
+            # Added by commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
+            # (2005-04-16) in v2.6.12, moved from linux/time.h to
+            # linux/timekeeping.h by commit
+            # 8b094cd03b4a3793220d8d8d86a173bfea8c285b (2014-07-16) in v3.17,
+            # and removed by e4b92b108c6cd6b311e4b6e85d6a87a34599a6e3
+            # (2018-12-07).
+            #
+            # Header file linux/ktime.h added by commit
+            # 97fc79f97b1111c80010d34ee66312b88f531e41 (2006-06-09) in v2.6.16,
+            # includes linux/time.h and/or linux/timekeeping.h.
+            #
+            CODE="
+            #include <linux/ktime.h>
+            void conftest_do_gettimeofday(void) {
+                do_gettimeofday();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DO_GETTIMEOFDAY_PRESENT" "" "functions"
+        ;;
+
+        drm_framebuffer_get)
+            #
+            # Determine if the function drm_framebuffer_get() is present.
+            #
+            # Added by commit a4a69da06bc1 ("drm: Introduce
+            # drm_framebuffer_{get,put}()") in v4.12 (2017-02-28).
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_FRAMEBUFFER_H_PRESENT)
+            #include <drm/drm_framebuffer.h>
+            #endif
+
+            void conftest_drm_framebuffer_get(void) {
+                drm_framebuffer_get();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_FRAMEBUFFER_GET_PRESENT" "" "functions"
+        ;;
+
+        drm_gem_object_get)
+            #
+            # Determine if the function drm_gem_object_get() is present.
+            #
+            # Added by commit e6b62714e87c ("drm: Introduce
+            # drm_gem_object_{get,put}()") in v4.12 (2017-02-28).
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_GEM_H_PRESENT)
+            #include <drm/drm_gem.h>
+            #endif
+            void conftest_drm_gem_object_get(void) {
+                drm_gem_object_get();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_GEM_OBJECT_GET_PRESENT" "" "functions"
+        ;;
+
+        drm_dev_put)
+            #
+            # Determine if the function drm_dev_put() is present.
+            #
+            # Added by commit 9a96f55034e4 ("drm: introduce drm_dev_{get/put}
+            # functions") in v4.15 (2017-09-26).
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_DRV_H_PRESENT)
+            #include <drm/drm_drv.h>
+            #endif
+            void conftest_drm_dev_put(void) {
+                drm_dev_put();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_DEV_PUT_PRESENT" "" "functions"
+        ;;
+
+        drm_connector_list_iter)
+            #
+            # Determine if the drm_connector_list_iter struct is present.
+            #
+            # Added by commit 613051dac40da1751ab269572766d3348d45a197 ("drm:
+            # locking&new iterators for connector_list") in v4.11 (2016-12-14).
+            #
+            CODE="
+            #include <drm/drm_connector.h>
+            int conftest_drm_connector_list_iter(void) {
+                struct drm_connector_list_iter conn_iter;
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_CONNECTOR_LIST_ITER_PRESENT" "" "types"
+
+            #
+            # Determine if the function drm_connector_list_iter_get() is
+            # renamed to drm_connector_list_iter_begin().
+            #
+            # Renamed by b982dab1e66d2b998e80a97acb6eaf56518988d3 (drm: Rename
+            # connector list iterator API) in v4.12 (2017-02-28).
+            #
+            CODE="
+            #if defined(NV_DRM_DRM_CONNECTOR_H_PRESENT)
+            #include <drm/drm_connector.h>
+            #endif
+            void conftest_drm_connector_list_iter_begin(void) {
+                drm_connector_list_iter_begin();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_CONNECTOR_LIST_ITER_BEGIN_PRESENT" "" "functions"
+        ;;
+
+        drm_atomic_helper_swap_state_has_stall_arg)
+            #
+            # Determine if drm_atomic_helper_swap_state() has 'stall' argument.
+            #
+            # drm_atomic_helper_swap_state() function prototype updated to take
+            # 'state' and 'stall' arguments by commit
+            # 5e84c2690b805caeff3b4c6c9564c7b8de54742d (drm/atomic-helper:
+            # Massage swap_state signature somewhat)
+            # in v4.8 (2016-06-10).
+            #
+            CODE="
+            #include <drm/drm_atomic_helper.h>
+            void conftest_drm_atomic_helper_swap_state_has_stall_arg(
+                    struct drm_atomic_state *state,
+                    bool stall) {
+                (void)drm_atomic_helper_swap_state(state, stall);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_ATOMIC_HELPER_SWAP_STATE_HAS_STALL_ARG" | append_conftest "types"
+
+            #
+            # Determine if drm_atomic_helper_swap_state() returns int.
+            #
+            # drm_atomic_helper_swap_state() function prototype
+            # updated to return int by commit
+            # c066d2310ae9bbc695c06e9237f6ea741ec35e43 (drm/atomic: Change
+            # drm_atomic_helper_swap_state to return an error.) in v4.14
+            # (2017-07-11).
+            #
+            CODE="
+            #include <drm/drm_atomic_helper.h>
+            int conftest_drm_atomic_helper_swap_state_return_int(
+                    struct drm_atomic_state *state,
+                    bool stall) {
+                return drm_atomic_helper_swap_state(state, stall);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_ATOMIC_HELPER_SWAP_STATE_RETURN_INT" | append_conftest "types"
+        ;;
+
+        pm_runtime_available)
+            #
+            # Determine if struct dev_pm_info has the 'usage_count' field.
+            #
+            # This was added to the kernel in commit 5e928f77a09a0 in v2.6.32
+            # (2008-08-18), but originally were dependent on CONFIG_PM_RUNTIME,
+            # which was folded into the more generic CONFIG_PM in commit
+            # d30d819dc8310 in v3.19 (2014-11-27).
+            # Rather than attempt to select the appropriate CONFIG option,
+            # simply check if this member is present.
+            #
+            CODE="
+            #include <linux/pm.h>
+            void pm_runtime_conftest(void) {
+                struct dev_pm_info dpmi;
+                atomic_set(&dpmi.usage_count, 1);
+            }"
+
+            compile_check_conftest "$CODE" "NV_PM_RUNTIME_AVAILABLE" "" "generic"
+        ;;
+
+        device_driver_of_match_table)
+            #
+            # Determine if the device_driver struct has an of_match_table member.
+            #
+            # of_match_table was added by commit 597b9d1e44e9 ("drivercore:
+            # Add of_match_table to the common device drivers") in v2.6.35
+            # (2010-04-13).
+            #
+            CODE="
+            #include <linux/device.h>
+            int conftest_device_driver_of_match_table(void) {
+                return offsetof(struct device_driver, of_match_table);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DEVICE_DRIVER_OF_MATCH_TABLE_PRESENT" "" "types"
+        ;;
+
+        device_of_node)
+            #
+            # Determine if the device struct has an of_node member.
+            #
+            # of_node member was added by commit d706c1b05027 ("driver-core:
+            # Add device node pointer to struct device") in v2.6.35
+            # (2010-04-13).
+            #
+            CODE="
+            #include <linux/device.h>
+            int conftest_device_of_node(void) {
+                return offsetof(struct device, of_node);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DEVICE_OF_NODE_PRESENT" "" "types"
+        ;;
+
+        dev_is_pci)
+            #
+            # Determine if the dev_is_pci() macro is present.
+            #
+            # dev_is_pci() macro was added by commit fb8a0d9d1bfd ("pci: Add
+            # SR-IOV convenience functions and macros") in v2.6.34
+            # (2010-02-10).
+            #
+            CODE="
+            #include <linux/pci.h>
+            void conftest_dev_is_pci(void) {
+                if(dev_is_pci()) {}
+            }
+            "
+
+            compile_check_conftest "$CODE" "NV_DEV_IS_PCI_PRESENT" "" "functions"
+        ;;
+
+        of_find_matching_node)
+            #
+            # Determine if the of_find_matching_node() function is present.
+            #
+            # Test if linux/of.h header file inclusion is successful or not and
+            # define/undefine NV_LINUX_OF_H_USABLE depending upon status of inclusion.
+            #
+            # of_find_matching_node was added by commit 283029d16a88
+            # ("[POWERPC] Add of_find_matching_node() helper function") in
+            # v2.6.25 (2008-01-09).
+            #
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/of.h>
+            " > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                rm -f conftest$$.o
+                echo "#define NV_LINUX_OF_H_USABLE" | append_conftest "generic"
+                CODE="
+                #include <linux/of.h>
+                void conftest_of_find_matching_node() {
+                    of_find_matching_node();
+                }"
+
+                compile_check_conftest "$CODE" "NV_OF_FIND_MATCHING_NODE_PRESENT" "" "functions"
+            else
+                echo "#undef NV_LINUX_OF_H_USABLE" | append_conftest "generic"
+                echo "#undef NV_OF_FIND_MATCHING_NODE_PRESENT" | append_conftest "functions"
+            fi
+        ;;
+
+        dma_direct_map_resource)
+            #
+            # Determine whether dma_is_direct() exists.
+            #
+            # dma_is_direct() was added by commit 356da6d0cde3 ("dma-mapping:
+            # bypass indirect calls for dma-direct") in 5.1 (2018-12-06).
+            #
+            # If dma_is_direct() does exist, then we assume that
+            # dma_direct_map_resource() exists.  Both functions were added
+            # as part of the same patchset.
+            #
+            # The presence of dma_is_direct() and dma_direct_map_resource()
+            # means that dma_direct can perform DMA mappings itself.
+            #
+            CODE="
+            #include <linux/dma-mapping.h>
+            void conftest_dma_is_direct(void) {
+                dma_is_direct();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DMA_IS_DIRECT_PRESENT" "" "functions"
+        ;;
+
+        tegra_get_platform)
+            #
+            # Determine if tegra_get_platform() function is present
+            #
+            CODE="
+            #if defined NV_SOC_TEGRA_CHIP_ID_H_PRESENT
+            #include <soc/tegra/chip-id.h>
+            #endif
+            void conftest_tegra_get_platform(void) {
+                tegra_get_platform(0);
+            }
+            "
+
+            compile_check_conftest "$CODE" "NV_TEGRA_GET_PLATFORM_PRESENT" "" "functions"
+        ;;
+
+        drm_alpha_blending_available)
+            #
+            # Determine if the DRM subsystem supports alpha blending
+            #
+            # This conftest using "generic" rather than "functions" because
+            # with the logic of "functions" the presence of
+            # *either*_alpha_property or _blend_mode_property would be enough
+            # to cause NV_DRM_ALPHA_BLENDING_AVAILABLE to be defined.
+            #
+            CODE="
+            #if defined(NV_DRM_DRM_BLEND_H_PRESENT)
+            #include <drm/drm_blend.h>
+            #endif
+            void conftest_drm_alpha_blending_available(void) {
+                /* 2018-04-11 ae0e28265e216dad11d4cbde42fc15e92919af78 */
+                (void)drm_plane_create_alpha_property;
+
+                /* 2018-08-23 a5ec8332d4280500544e316f76c04a7adc02ce03 */
+                (void)drm_plane_create_blend_mode_property;
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_ALPHA_BLENDING_AVAILABLE" "" "generic"
+        ;;
+
+        drm_driver_prime_flag_present)
+            #
+            # Determine whether driver feature flag DRIVER_PRIME is present.
+            #
+            # The DRIVER_PRIME flag was added by commit 3248877ea179 (drm:
+            # base prime/dma-buf support (v5)) in v3.4 (2011-11-25) and is
+            # removed by commit 0424fdaf883a (drm/prime: Actually remove
+            # DRIVER_PRIME everywhere) on 2019-06-17.
+            #
+            # DRIVER_PRIME definition moved from drmP.h to drm_drv.h by
+            # commit 85e634bce01a (drm: Extract drm_drv.h) in v4.10
+            # (2016-11-14).
+            #
+            # DRIVER_PRIME define is changed to enum value by commit
+            # 0e2a933b02c9 (drm: Switch DRIVER_ flags to an enum) in v5.1
+            # (2019-01-29).
+            #
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_DRV_H_PRESENT)
+            #include <drm/drm_drv.h>
+            #endif
+
+            unsigned int drm_driver_prime_flag_present_conftest(void) {
+                return DRIVER_PRIME;
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_DRIVER_PRIME_FLAG_PRESENT" "" "types"
+        ;;
+
+        drm_connector_for_each_possible_encoder)
+            #
+            # Determine the number of arguments of the
+            # drm_connector_for_each_possible_encoder() macro.
+            #
+            # drm_connector_for_each_possible_encoder() is added by commit
+            # 83aefbb887b5 (drm: Add drm_connector_for_each_possible_encoder())
+            # in v4.19. The definition and prorotype is changed to take only
+            # two arguments connector and encoder, by commit 62afb4ad425a
+            # (drm/connector: Allow max possible encoders to attach to a
+            # connector) in v5.5rc1.
+            #
+            echo "$CONFTEST_PREAMBLE
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_CONNECTOR_H_PRESENT)
+            #include <drm/drm_connector.h>
+            #endif
+
+            void conftest_drm_connector_for_each_possible_encoder(
+                struct drm_connector *connector,
+                struct drm_encoder *encoder,
+                int i) {
+
+                drm_connector_for_each_possible_encoder(connector, encoder, i) {
+                }
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_DRM_CONNECTOR_FOR_EACH_POSSIBLE_ENCODER_ARGUMENT_COUNT 3" | append_conftest "functions"
+                rm -f conftest$$.o
+                return
+            else
+                echo "#define NV_DRM_CONNECTOR_FOR_EACH_POSSIBLE_ENCODER_ARGUMENT_COUNT 2" | append_conftest "functions"
+            fi
+        ;;
+
+        mmu_notifier_ops_invalidate_range)
+            #
+            # Determine if the mmu_notifier_ops struct has the
+            # 'invalidate_range' member.
+            #
+            # struct mmu_notifier_ops.invalidate_range was added by commit
+            # 0f0a327fa12cd55de5e7f8c05a70ac3d047f405e ("mmu_notifier: add the
+            # callback for mmu_notifier_invalidate_range()") in v3.19
+            # (2014-11-13).
+            CODE="
+            #include <linux/mmu_notifier.h>
+            int conftest_mmu_notifier_ops_invalidate_range(void) {
+                return offsetof(struct mmu_notifier_ops, invalidate_range);
+            }"
+
+            compile_check_conftest "$CODE" "NV_MMU_NOTIFIER_OPS_HAS_INVALIDATE_RANGE" "" "types"
+        ;;
+
+        drm_format_num_planes)
+            #
+            # Determine if drm_format_num_planes() function is present.
+            #
+            # The drm_format_num_planes() function was added by commit
+            # d0d110e09629 drm: Add drm_format_num_planes() utility function in
+            # v3.3 (2011-12-20). Prototype was moved from drm_crtc.h to
+            # drm_fourcc.h by commit ae4df11a0f53 (drm: Move format-related
+            # helpers to drm_fourcc.c) in v4.8 (2016-06-09).
+            # drm_format_num_planes() has been removed by commit 05c452c115bf
+            # (drm: Remove users of drm_format_num_planes) removed v5.3
+            # (2019-05-16).
+            #
+            CODE="
+
+            #if defined(NV_DRM_DRM_CRTC_H_PRESENT)
+            #include <drm/drm_crtc.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_FOURCC_H_PRESENT)
+            #include <drm/drm_fourcc.h>
+            #endif
+
+            void conftest_drm_format_num_planes(void) {
+                drm_format_num_planes();
+            }
+            "
+
+            compile_check_conftest "$CODE" "NV_DRM_FORMAT_NUM_PLANES_PRESENT" "" "functions"
+        ;;
+
+        drm_gem_object_has_resv)
+            #
+            # Determine if the 'drm_gem_object' structure has a 'resv' field.
+            #
+            # A 'resv' filed in the 'drm_gem_object' structure, is added by
+            # commit 1ba627148ef5 (drm: Add reservation_object to
+            # drm_gem_object) in v5.2.
+            #
+            CODE="$CONFTEST_PREAMBLE
+            #if defined(NV_DRM_DRM_GEM_H_PRESENT)
+            #include <drm/drm_gem.h>
+            #endif
+
+            int conftest_drm_gem_object_has_resv(void) {
+                return offsetof(struct drm_gem_object, resv);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_GEM_OBJECT_HAS_RESV" "" "types"
+        ;;
+
+        proc_ops)
+            #
+            # Determine if the 'struct proc_ops' type is present.
+            #
+            # Added by commit d56c0d45f0e2 ("proc: decouple proc from VFS with 
+            # "struct proc_ops"") in 5.6-rc1
+            #
+            CODE="
+            #include <linux/proc_fs.h>
+
+            struct proc_ops p_ops;
+            "
+
+            compile_check_conftest "$CODE" "NV_PROC_OPS_PRESENT" "" "types"
+        ;;
+
+        timeval)
+            #
+            # Determine if the 'struct timeval' type is present.
+            #
+            # Removed by commit c766d1472c70 ("y2038: hide 
+            # timeval/timespec/itimerval/itimerspec types") in 5.6-rc3
+            # (2020-02-20).
+            #
+            CODE="
+            #include <linux/time.h>
+
+            struct timeval tm;
+            "
+
+            compile_check_conftest "$CODE" "NV_TIMEVAL_PRESENT" "" "types"
+        ;;
+
+        ktime_get_raw_ts64)
+            #
+            # Determine if ktime_get_raw_ts64() is present
+            #
+            # Added by commit fb7fcc96a86cf ("timekeeping: Standardize on
+            # ktime_get_*() naming") in 4.18 (2018-04-27)
+            #
+        CODE="
+        #include <linux/ktime.h>
+        void conftest_ktime_get_raw_ts64(void){
+            ktime_get_raw_ts64();
+        }"
+            compile_check_conftest "$CODE" "NV_KTIME_GET_RAW_TS64_PRESENT" "" "functions"
+        ;;
+
+        ktime_get_real_ts64)
+            #
+            # Determine if ktime_get_real_ts64() is present
+            #
+            # Added by commit d6d29896c665d ("timekeeping: Provide timespec64
+            # based interfaces") in 3.17 (2014-07-16)
+            #
+        CODE="
+        #include <linux/ktime.h>
+        void conftest_ktime_get_real_ts64(void){
+            ktime_get_real_ts64();
+        }"
+            compile_check_conftest "$CODE" "NV_KTIME_GET_REAL_TS64_PRESENT" "" "functions"
+        ;;
+
+        vmalloc_has_pgprot_t_arg)
+            #
+            # Determine if __vmalloc has the 'pgprot' argument.
+            #
+            # The third argument to __vmalloc, page protection
+            # 'pgprot_t prot', was removed by commit 88dca4ca5a93
+            # (mm: remove the pgprot argument to __vmalloc)
+            # in v5.8-rc1 (2020-06-01).
+        CODE="
+        #include <linux/vmalloc.h>
+
+        void conftest_vmalloc_has_pgprot_t_arg(void) {
+            pgprot_t prot;
+            (void)__vmalloc(0, 0, prot);
+        }"
+
+            compile_check_conftest "$CODE" "NV_VMALLOC_HAS_PGPROT_T_ARG" "" "types"
+
+        ;;
+
+        mm_has_mmap_lock)
+            #
+            # Determine if the 'mm_struct' structure has a 'mmap_lock' field.
+            #
+            # Kernel commit da1c55f1b272 ("mmap locking API: rename mmap_sem
+            # to mmap_lock") replaced the field 'mmap_sem' by 'mmap_lock'
+            # in v5.8-rc1 (2020-06-08).
+            CODE="
+            #include <linux/mm_types.h>
+
+            int conftest_mm_has_mmap_lock(void) {
+                return offsetof(struct mm_struct, mmap_lock);
+            }"
+
+            compile_check_conftest "$CODE" "NV_MM_HAS_MMAP_LOCK" "" "types"
+
+        ;;
+
+        # When adding a new conftest entry, please use the correct format for
+        # specifying the relevant upstream Linux kernel commit.
+        #
+        # <function> was added|removed|etc by commit <sha> ("<commit message")
+        # in <kernel-version> (<commit date>).
+
+        *)
+            # Unknown test name given
+            echo "Error: unknown conftest '$1' requested" >&2
+            exit 1
+        ;;
+    esac
+}
+
+case "$5" in
+    cc_sanity_check)
+        #
+        # Check if the selected compiler can create object files
+        # in the current environment.
+        #
+        VERBOSE=$6
+
+        echo "int cc_sanity_check(void) {
+            return 0;
+        }" > conftest$$.c
+
+        $CC -c conftest$$.c > /dev/null 2>&1
+        rm -f conftest$$.c
+
+        if [ ! -f conftest$$.o ]; then
+            if [ "$VERBOSE" = "full_output" ]; then
+                echo "";
+            fi
+            if [ "$CC" != "cc" ]; then
+                echo "The C compiler '$CC' does not appear to be able to"
+                echo "create object files.  Please make sure you have "
+                echo "your Linux distribution's libc development package"
+                echo "installed and that '$CC' is a valid C compiler";
+                echo "name."
+            else
+                echo "The C compiler '$CC' does not appear to be able to"
+                echo "create executables.  Please make sure you have "
+                echo "your Linux distribution's gcc and libc development"
+                echo "packages installed."
+            fi
+            if [ "$VERBOSE" = "full_output" ]; then
+                echo "";
+                echo "*** Failed CC sanity check. Bailing out! ***";
+                echo "";
+            fi
+            exit 1
+        else
+            rm -f conftest$$.o
+            exit 0
+        fi
+    ;;
+
+    cc_version_check)
+        #
+        # Verify that the same compiler major and minor version is
+        # used for the kernel and kernel module.
+        #
+        # Some gcc version strings that have proven problematic for parsing
+        # in the past:
+        #
+        #  gcc.real (GCC) 3.3 (Debian)
+        #  gcc-Version 3.3 (Debian)
+        #  gcc (GCC) 3.1.1 20020606 (Debian prerelease)
+        #  version gcc 3.2.3
+        #
+        VERBOSE=$6
+
+        kernel_compile_h=$OUTPUT/include/generated/compile.h
+
+        if [ ! -f ${kernel_compile_h} ]; then
+            # The kernel's compile.h file is not present, so there
+            # isn't a convenient way to identify the compiler version
+            # used to build the kernel.
+            IGNORE_CC_MISMATCH=1
+        fi
+
+        if [ -n "$IGNORE_CC_MISMATCH" ]; then
+            exit 0
+        fi
+
+        kernel_cc_string=`cat ${kernel_compile_h} | \
+            grep LINUX_COMPILER | cut -f 2 -d '"'`
+
+        kernel_cc_version=`echo ${kernel_cc_string} | grep -o '[0-9]\+\.[0-9]\+' | head -n 1`
+        kernel_cc_major=`echo ${kernel_cc_version} | cut -d '.' -f 1`
+        kernel_cc_minor=`echo ${kernel_cc_version} | cut -d '.' -f 2`
+
+        echo "
+        #if (__GNUC__ != ${kernel_cc_major}) || (__GNUC_MINOR__ != ${kernel_cc_minor})
+        #error \"cc version mismatch\"
+        #endif
+        " > conftest$$.c
+
+        $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+        rm -f conftest$$.c
+
+        if [ -f conftest$$.o ]; then
+            rm -f conftest$$.o
+            exit 0;
+        else
+            #
+            # The gcc version check failed
+            #
+
+            if [ "$VERBOSE" = "full_output" ]; then
+                echo "";
+                echo "Compiler version check failed:";
+                echo "";
+                echo "The major and minor number of the compiler used to";
+                echo "compile the kernel:";
+                echo "";
+                echo "${kernel_cc_string}";
+                echo "";
+                echo "does not match the compiler used here:";
+                echo "";
+                $CC --version
+                echo "";
+                echo "It is recommended to set the CC environment variable";
+                echo "to the compiler that was used to compile the kernel.";
+                echo ""
+                echo "The compiler version check can be disabled by setting";
+                echo "the IGNORE_CC_MISMATCH environment variable to \"1\".";
+                echo "However, mixing compiler versions between the kernel";
+                echo "and kernel modules can result in subtle bugs that are";
+                echo "difficult to diagnose.";
+                echo "";
+                echo "*** Failed CC version check. Bailing out! ***";
+                echo "";
+            elif [ "$VERBOSE" = "just_msg" ]; then
+                echo "The kernel was built with ${kernel_cc_string}, but the" \
+                     "current compiler version is `$CC --version | head -n 1`.";
+            fi
+            exit 1;
+        fi
+    ;;
+
+    xen_sanity_check)
+        #
+        # Check if the target kernel is a Xen kernel. If so, exit, since
+        # the RM doesn't currently support Xen.
+        #
+        VERBOSE=$6
+
+        if [ -n "$IGNORE_XEN_PRESENCE" -o -n "$VGX_BUILD" ]; then
+            exit 0
+        fi
+
+        test_xen
+
+        if [ "$XEN_PRESENT" != "0" ]; then
+            echo "The kernel you are installing for is a Xen kernel!";
+            echo "";
+            echo "The NVIDIA driver does not currently support Xen kernels. If ";
+            echo "you are using a stock distribution kernel, please install ";
+            echo "a variant of this kernel without Xen support; if this is a ";
+            echo "custom kernel, please install a standard Linux kernel.  Then ";
+            echo "try installing the NVIDIA kernel module again.";
+            echo "";
+            if [ "$VERBOSE" = "full_output" ]; then
+                echo "*** Failed Xen sanity check. Bailing out! ***";
+                echo "";
+            fi
+            exit 1
+        else
+            exit 0
+        fi
+    ;;
+
+    preempt_rt_sanity_check)
+        #
+        # Check if the target kernel has the PREEMPT_RT patch set applied. If
+        # so, exit, since the RM doesn't support this configuration.
+        #
+        VERBOSE=$6
+
+        if [ -n "$IGNORE_PREEMPT_RT_PRESENCE" ]; then
+            exit 0
+        fi
+
+        if test_configuration_option CONFIG_PREEMPT_RT; then
+            PREEMPT_RT_PRESENT=1
+        elif test_configuration_option CONFIG_PREEMPT_RT_FULL; then
+            PREEMPT_RT_PRESENT=1
+        fi
+
+        if [ "$PREEMPT_RT_PRESENT" != "0" ]; then
+            echo "The kernel you are installing for is a PREEMPT_RT kernel!";
+            echo "";
+            echo "The NVIDIA driver does not support real-time kernels. If you ";
+            echo "are using a stock distribution kernel, please install ";
+            echo "a variant of this kernel that does not have the PREEMPT_RT ";
+            echo "patch set applied; if this is a custom kernel, please ";
+            echo "install a standard Linux kernel.  Then try installing the ";
+            echo "NVIDIA kernel module again.";
+            echo "";
+            if [ "$VERBOSE" = "full_output" ]; then
+                echo "*** Failed PREEMPT_RT sanity check. Bailing out! ***";
+                echo "";
+            fi
+            exit 1
+        else
+            exit 0
+        fi
+    ;;
+
+    patch_check)
+        #
+        # Check for any "official" patches that may have been applied and
+        # construct a description table for reporting purposes.
+        #
+        PATCHES=""
+
+        for PATCH in patch-*.h; do
+            if [ -f $PATCH ]; then
+                echo "#include \"$PATCH\""
+                PATCHES="$PATCHES "`echo $PATCH | sed -s 's/patch-\(.*\)\.h/\1/'`
+            fi
+        done
+
+        echo "static struct {
+                const char *short_description;
+                const char *description;
+              } __nv_patches[] = {"
+            for i in $PATCHES; do
+                echo "{ \"$i\", NV_PATCH_${i}_DESCRIPTION },"
+            done
+        echo "{ NULL, NULL } };"
+
+        exit 0
+    ;;
+
+    compile_tests)
+        #
+        # Run a series of compile tests to determine the set of interfaces
+        # and features available in the target kernel.
+        #
+        shift 5
+
+        CFLAGS=$1
+        shift
+
+        for i in $*; do compile_test $i; done
+
+        for file in conftest*.d; do
+            rm -f $file > /dev/null 2>&1
+        done
+
+        exit 0
+    ;;
+
+    dom0_sanity_check)
+        #
+        # Determine whether running in DOM0.
+        #
+        VERBOSE=$6
+
+        if [ -n "$VGX_BUILD" ]; then
+            if [ -f /proc/xen/capabilities ]; then
+                if [ "`cat /proc/xen/capabilities`" == "control_d" ]; then
+                    exit 0
+                fi
+            else
+                echo "The kernel is not running in DOM0.";
+                echo "";
+                if [ "$VERBOSE" = "full_output" ]; then
+                    echo "*** Failed DOM0 sanity check. Bailing out! ***";
+                    echo "";
+                fi
+            fi
+            exit 1
+        fi
+    ;;
+    vgpu_kvm_sanity_check)
+        #
+        # Determine whether we are running a vGPU on KVM host.
+        #
+        VERBOSE=$6
+        iommu=CONFIG_VFIO_IOMMU_TYPE1
+        mdev=CONFIG_VFIO_MDEV_DEVICE
+        kvm=CONFIG_KVM_VFIO
+
+        if [ -n "$VGX_KVM_BUILD" ]; then
+            if (test_configuration_option ${iommu} || test_configuration_option ${iommu}_MODULE) &&
+               (test_configuration_option ${mdev} || test_configuration_option ${mdev}_MODULE) &&
+               (test_configuration_option ${kvm} || test_configuration_option ${kvm}_MODULE); then
+                    exit 0
+            else
+                echo "The kernel is not running a vGPU on KVM host.";
+                echo "";
+                if [ "$VERBOSE" = "full_output" ]; then
+                    echo "*** Failed vGPU on KVM sanity check. Bailing out! ***";
+                    echo "";
+                fi
+            fi
+            exit 1
+        else
+            exit 0
+        fi
+    ;;
+    test_configuration_option)
+        #
+        # Check to see if the given config option is set.
+        #
+        OPTION=$6
+
+        test_configuration_option $OPTION
+        exit $?
+    ;;
+
+    get_configuration_option)
+        #
+        # Get the value of the given config option.
+        #
+        OPTION=$6
+
+        get_configuration_option $OPTION
+        exit $?
+    ;;
+
+
+    guess_module_signing_hash)
+        #
+        # Determine the best cryptographic hash to use for module signing,
+        # to the extent that is possible.
+        #
+
+        HASH=$(get_configuration_option CONFIG_MODULE_SIG_HASH)
+
+        if [ $? -eq 0 ] && [ -n $HASH ]; then
+            echo $HASH
+            exit 0
+        else
+            for SHA in 512 384 256 224 1; do
+                if test_configuration_option CONFIG_MODULE_SIG_SHA$SHA; then
+                    echo sha$SHA
+                    exit 0
+                fi
+            done
+        fi
+        exit 1
+    ;;
+
+
+    test_kernel_headers)
+        #
+        # Check for the availability of certain kernel headers
+        #
+
+        CFLAGS=$6
+
+        test_headers
+
+        for file in conftest*.d; do
+            rm -f $file > /dev/null 2>&1
+        done
+
+        exit $?
+    ;;
+
+
+    build_cflags)
+        #
+        # Generate CFLAGS for use in the compile tests
+        #
+
+        build_cflags
+        echo $CFLAGS
+        exit 0
+    ;;
+
+    module_symvers_sanity_check)
+        #
+        # Check whether Module.symvers exists and contains at least one
+        # EXPORT_SYMBOL* symbol from vmlinux
+        #
+
+        if [ -n "$IGNORE_MISSING_MODULE_SYMVERS" ]; then
+            exit 0
+        fi
+
+        TAB='	'
+
+        if [ -f "$OUTPUT/Module.symvers" ] && \
+             grep -e "^[^${TAB}]*${TAB}[^${TAB}]*${TAB}\+vmlinux" \
+                     "$OUTPUT/Module.symvers" >/dev/null 2>&1; then
+            exit 0
+        fi
+
+        echo "The Module.symvers file is missing, or does not contain any"
+        echo "symbols exported from the kernel. This could cause the NVIDIA"
+        echo "kernel modules to be built against a configuration that does"
+        echo "not accurately reflect the actual target kernel."
+        echo "The Module.symvers file check can be disabled by setting the"
+        echo "environment variable IGNORE_MISSING_MODULE_SYMVERS to 1."
+
+        exit 1
+    ;;
+esac
diff -ruN a/kernel/nvidia/nvidia.Kbuild b/kernel/nvidia/nvidia.Kbuild
--- a/kernel/nvidia/nvidia.Kbuild	2020-07-10 15:34:44.698455352 +0200
+++ b/kernel/nvidia/nvidia.Kbuild	2020-07-10 15:56:56.093556199 +0200
@@ -146,6 +146,7 @@
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += jiffies_to_timespec
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += ktime_get_raw_ts64
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += ktime_get_real_ts64
+NV_CONFTEST_FUNCTION_COMPILE_TESTS += vmalloc_argument_count
 
 NV_CONFTEST_SYMBOL_COMPILE_TESTS += is_export_symbol_gpl_of_node_to_nid
 NV_CONFTEST_SYMBOL_COMPILE_TESTS += is_export_symbol_present_swiotlb_map_sg_attrs
@@ -179,6 +180,7 @@
 NV_CONFTEST_TYPE_COMPILE_TESTS += vmalloc_has_pgprot_t_arg
 NV_CONFTEST_TYPE_COMPILE_TESTS += timeval
 NV_CONFTEST_TYPE_COMPILE_TESTS += mm_has_mmap_lock
+NV_CONFTEST_TYPE_COMPILE_TESTS += mm_struct_has_mmap_lock
 
 NV_CONFTEST_GENERIC_COMPILE_TESTS += dom0_kernel_present
 NV_CONFTEST_GENERIC_COMPILE_TESTS += nvidia_vgpu_hyperv_available
