diff -ruN a/kernel/common/inc/nv-mm.h b/kernel/common/inc/nv-mm.h
--- a/kernel/common/inc/nv-mm.h	2020-08-19 15:16:30.940000614 +0200
+++ b/kernel/common/inc/nv-mm.h	2020-08-19 15:18:13.180000809 +0200
@@ -144,6 +144,11 @@
                return get_user_pages_remote(tsk, mm, start, nr_pages, flags,
                                             pages, vmas, NULL);
 
+        #elif defined(NV_GET_USER_PAGES_REMOTE_REMOVED_TSK_ARG)
+
+               return get_user_pages_remote(mm, start, nr_pages, flags,
+                                            pages, vmas, NULL);
+
         #else
 
                return get_user_pages_remote(tsk, mm, start, nr_pages, flags,
diff -ruN a/kernel/conftest.sh b/kernel/conftest.sh
--- a/kernel/conftest.sh	2020-08-19 15:16:30.930000614 +0200
+++ b/kernel/conftest.sh	2020-08-19 15:18:13.180000809 +0200
@@ -2034,6 +2034,65 @@
             compile_check_conftest "$CODE" "NV_DRM_DRIVER_HAS_LEGACY_DEV_LIST" "" "types"
         ;;
 
+        drm_driver_has_gem_free_object)
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_DRV_H_PRESENT)
+            #include <drm/drm_drv.h>
+            #endif
+
+            int conftest_drm_driver_has_gem_free_object(void) {
+                return offsetof(struct drm_driver, gem_free_object);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_DRIVER_HAS_GEM_FREE_OBJECT" "" "types"
+        ;;
+
+        drm_display_mode_has_vrefresh)
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_DRV_H_PRESENT)
+            #include <drm/drm_drv.h>
+            #endif
+
+            int conftest_drm_display_mode_has_vrefresh(void) {
+                return offsetof(struct drm_display_mode, vrefresh);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_DISPLAY_MODE_HAS_VREFRESH" "" "types"
+        ;;
+
+        drm_master_set_returns_int)
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+
+            #if defined(NV_DRM_DRM_DRV_H_PRESENT)
+            #include <drm/drm_drv.h>
+            #endif
+
+            static int nv_master_set(struct drm_device *x, struct drm_file *y, bool z)
+            {
+                return 1;
+            }
+
+            int conftest_drm_master_set_returns_int(void) {
+                struct drm_driver nv_drm_driver;
+                nv_drm_driver.master_set = nv_master_set;
+
+                return nv_drm_driver.master_set(NULL, NULL, false);
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_MASTER_SET_RETURNS_INT" "" "generic"
+        ;;
+
         jiffies_to_timespec)
             #
             # Determine if jiffies_to_timespec() is present
@@ -2645,6 +2704,29 @@
             fi
             echo "#undef NV_GET_USER_PAGES_REMOTE_HAS_WRITE_AND_FORCE_ARGS" | append_conftest "functions"
 
+            # conftest #4: check if get_user_pages_remote() has removed tsk argument
+
+            echo "$CONFTEST_PREAMBLE
+            #include <linux/mm.h>
+            long get_user_pages_remote(struct mm_struct *mm,
+                                       unsigned long start,
+                                       unsigned long nr_pages,
+                                       unsigned int gup_flags,
+                                       struct page **pages,
+                                       struct vm_area_struct **vmas,
+                                       int *locked) {
+                return 0;
+            }" > conftest$$.c
+
+            $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+            rm -f conftest$$.c
+
+            if [ -f conftest$$.o ]; then
+                echo "#define NV_GET_USER_PAGES_REMOTE_REMOVED_TSK_ARG" | append_conftest "functions"
+                rm -f conftest$$.o
+            else
+                echo "#undef NV_GET_USER_PAGES_REMOTE_REMOVED_TSK_ARG" | append_conftest "functions"
+            fi
         ;;
 
         usleep_range)
@@ -2710,6 +2792,21 @@
             fi
         ;;
 
+        drm_gem_object_put_unlocked)
+            CODE="
+            #if defined(NV_DRM_DRMP_H_PRESENT)
+            #include <drm/drmP.h>
+            #endif
+            #if defined(NV_DRM_DRM_GEM_H_PRESENT)
+            #include <drm/drm_gem.h>
+            #endif
+            int conftest_drm_gem_object_put_unlocked(void) {
+                drm_gem_object_put_unlocked();
+            }"
+
+            compile_check_conftest "$CODE" "NV_DRM_GEM_OBJECT_PUT_UNLOCKED_PRESENT" "" "functions"
+        ;;
+
         drm_master_drop_has_from_release_arg)
             #
             # Determine if drm_driver::master_drop() has 'from_release' argument.
@@ -3801,6 +3898,26 @@
 
         ;;
 
+        smp_read_barrier_depends)
+            CODE="
+            #include <asm/barrier.h>
+            void conftest_smp_read_barrier_depends(void) {
+                smp_read_barrier_depends(0);
+            }"
+
+            compile_check_conftest "$CODE" "NV_SMP_READ_BARRIER_DEPENDS_PRESENT" "" "functions"
+        ;;
+
+        vga_tryget)
+            CODE="
+            #include <linux/vgaarb.h>
+            void conftest_vga_tryget(void) {
+                vga_tryget();
+            }"
+
+            compile_check_conftest "$CODE" "NV_VGA_TRYGET_PRESENT" "" "functions"
+        ;;
+
         # When adding a new conftest entry, please use the correct format for
         # specifying the relevant upstream Linux kernel commit.
         #
diff -ruN a/kernel/nvidia/nv-caps.c b/kernel/nvidia/nv-caps.c
--- a/kernel/nvidia/nv-caps.c	2020-08-19 15:16:30.870000614 +0200
+++ b/kernel/nvidia/nv-caps.c	2020-08-19 15:24:57.820001579 +0200
@@ -631,7 +631,7 @@
 #if NV_IS_EXPORT_SYMBOL_PRESENT___close_fd
     __close_fd(current->files, fd);
 #else
-    sys_close(fd);
+    ksys_close(fd);
 #endif
 
     task_unlock(current);
diff -ruN a/kernel/nvidia/nv-caps.c.orig b/kernel/nvidia/nv-caps.c.orig
--- a/kernel/nvidia/nv-caps.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ b/kernel/nvidia/nv-caps.c.orig	2020-08-19 15:16:39.980000632 +0200
@@ -0,0 +1,929 @@
+/*******************************************************************************
+    Copyright (c) 2019 NVIDIA Corporation
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to
+    deal in the Software without restriction, including without limitation the
+    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+    sell copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+        The above copyright notice and this permission notice shall be
+        included in all copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+
+*******************************************************************************/
+
+#include "nv-linux.h"
+#include "nv-caps.h"
+#include "nv-procfs.h"
+
+/*
+ * This temporary module parameter will be nuked soon when devfs support
+ * is enabled by default.
+ */
+static int nv_cap_enable_devfs = 0;
+module_param(nv_cap_enable_devfs, int, S_IRUGO);
+MODULE_PARM_DESC(nv_cap_enable_devfs, "Enable (1) or disable (0) nv-caps " \
+                 "devfs support. Default: 0");
+
+extern int NVreg_ModifyDeviceFiles;
+
+/* sys_close() or __close_fd() */
+#include <linux/syscalls.h>
+
+#define NV_CAP_DRV_MINOR_COUNT 8192
+
+typedef struct nv_cap_table_entry
+{
+    const char *name;
+    int minor;
+} nv_cap_table_entry_t;
+
+#define NV_CAP_NUM_ENTRIES(_table) (sizeof(_table) / sizeof(_table[0]))
+
+static nv_cap_table_entry_t g_nv_cap_nvlink_table[] =
+{
+    { "fabric-mgmt", -1 }
+};
+
+static nv_cap_table_entry_t g_nv_cap_mig_table[] =
+{
+    { "config", -1 },
+    { "monitor", -1 }
+};
+
+#define NV_CAP_MIG_CI_ENTRIES(_gi) \
+    { _gi"/ci0/access", -1 },      \
+    { _gi"/ci1/access", -1 },      \
+    { _gi"/ci2/access", -1 },      \
+    { _gi"/ci3/access", -1 },      \
+    { _gi"/ci4/access", -1 },      \
+    { _gi"/ci5/access", -1 },      \
+    { _gi"/ci6/access", -1 },      \
+    { _gi"/ci7/access", -1 }
+
+#define NV_CAP_MIG_GI_ENTRIES(_gpu) \
+    { "gi0/access", -1 },           \
+    NV_CAP_MIG_CI_ENTRIES("gi0"),   \
+    { "gi1/access", -1 },           \
+    NV_CAP_MIG_CI_ENTRIES("gi1"),   \
+    { "gi2/access", -1 },           \
+    NV_CAP_MIG_CI_ENTRIES("gi2"),   \
+    { "gi3/access", -1 },           \
+    NV_CAP_MIG_CI_ENTRIES("gi3"),   \
+    { "gi4/access", -1 },           \
+    NV_CAP_MIG_CI_ENTRIES("gi4"),   \
+    { "gi5/access", -1 },           \
+    NV_CAP_MIG_CI_ENTRIES("gi5"),   \
+    { "gi6/access", -1 },           \
+    NV_CAP_MIG_CI_ENTRIES("gi6"),   \
+    { "gi7/access", -1 },           \
+    NV_CAP_MIG_CI_ENTRIES("gi7"),   \
+    { "gi8/access", -1 },           \
+    NV_CAP_MIG_CI_ENTRIES("gi8"),   \
+    { "gi9/access", -1 },           \
+    NV_CAP_MIG_CI_ENTRIES("gi9"),   \
+    { "gi10/access", -1 },          \
+    NV_CAP_MIG_CI_ENTRIES("gi10"),  \
+    { "gi11/access", -1 },          \
+    NV_CAP_MIG_CI_ENTRIES("gi11"),  \
+    { "gi12/access", -1 },          \
+    NV_CAP_MIG_CI_ENTRIES("gi12"),  \
+    { "gi13/access", -1 },          \
+    NV_CAP_MIG_CI_ENTRIES("gi13"),  \
+    { "gi14/access", -1 },          \
+    NV_CAP_MIG_CI_ENTRIES("gi14")
+
+#define NV_CAP_MAX_GPUS 32
+
+static nv_cap_table_entry_t g_nv_cap_mig_gpu_table[] =
+{
+    NV_CAP_MIG_GI_ENTRIES("gpu0"),
+    NV_CAP_MIG_GI_ENTRIES("gpu1"),
+    NV_CAP_MIG_GI_ENTRIES("gpu2"),
+    NV_CAP_MIG_GI_ENTRIES("gpu3"),
+    NV_CAP_MIG_GI_ENTRIES("gpu4"),
+    NV_CAP_MIG_GI_ENTRIES("gpu5"),
+    NV_CAP_MIG_GI_ENTRIES("gpu6"),
+    NV_CAP_MIG_GI_ENTRIES("gpu7"),
+    NV_CAP_MIG_GI_ENTRIES("gpu8"),
+    NV_CAP_MIG_GI_ENTRIES("gpu9"),
+    NV_CAP_MIG_GI_ENTRIES("gpu10"),
+    NV_CAP_MIG_GI_ENTRIES("gpu11"),
+    NV_CAP_MIG_GI_ENTRIES("gpu12"),
+    NV_CAP_MIG_GI_ENTRIES("gpu13"),
+    NV_CAP_MIG_GI_ENTRIES("gpu14"),
+    NV_CAP_MIG_GI_ENTRIES("gpu15"),
+    NV_CAP_MIG_GI_ENTRIES("gpu16"),
+    NV_CAP_MIG_GI_ENTRIES("gpu17"),
+    NV_CAP_MIG_GI_ENTRIES("gpu18"),
+    NV_CAP_MIG_GI_ENTRIES("gpu19"),
+    NV_CAP_MIG_GI_ENTRIES("gpu20"),
+    NV_CAP_MIG_GI_ENTRIES("gpu21"),
+    NV_CAP_MIG_GI_ENTRIES("gpu22"),
+    NV_CAP_MIG_GI_ENTRIES("gpu23"),
+    NV_CAP_MIG_GI_ENTRIES("gpu24"),
+    NV_CAP_MIG_GI_ENTRIES("gpu25"),
+    NV_CAP_MIG_GI_ENTRIES("gpu26"),
+    NV_CAP_MIG_GI_ENTRIES("gpu27"),
+    NV_CAP_MIG_GI_ENTRIES("gpu28"),
+    NV_CAP_MIG_GI_ENTRIES("gpu29"),
+    NV_CAP_MIG_GI_ENTRIES("gpu30"),
+    NV_CAP_MIG_GI_ENTRIES("gpu31")
+};
+
+struct nv_cap
+{
+    char *path;
+    char *name;
+    int minor;
+    int permissions;
+    int modify;
+    struct proc_dir_entry *parent;
+    struct proc_dir_entry *entry;
+};
+
+#define NV_CAP_PROCFS_WRITE_BUF_SIZE 128
+
+typedef struct nv_cap_file_private
+{
+    int minor;
+    int permissions;
+    /* Will be used for fork() detection.*/
+    struct files_struct *files;
+    int modify;
+    char buffer[NV_CAP_PROCFS_WRITE_BUF_SIZE];
+    off_t offset;
+} nv_cap_file_private_t;
+
+struct
+{
+    NvBool initialized;
+    struct cdev cdev;
+    dev_t devno;
+} g_nv_cap_drv;
+
+#define NV_CAP_PROCFS_DIR "driver/nvidia-caps"
+
+static struct proc_dir_entry *nv_cap_procfs_dir;
+static struct proc_dir_entry *nv_cap_procfs_nvlink_minors;
+static struct proc_dir_entry *nv_cap_procfs_mig_minors;
+
+static int nv_procfs_read_nvlink_minors(struct seq_file *s, void *v)
+{
+    int i, count;
+
+    count = NV_CAP_NUM_ENTRIES(g_nv_cap_nvlink_table);
+    for (i = 0; i < count; i++)
+    {
+        seq_printf(s, "%s %d\n", g_nv_cap_nvlink_table[i].name,
+                   g_nv_cap_nvlink_table[i].minor);
+    }
+
+    return 0;
+}
+
+static int nv_procfs_read_mig_minors(struct seq_file *s, void *v)
+{
+    int i, j, count, index;
+
+    count = NV_CAP_NUM_ENTRIES(g_nv_cap_mig_table);
+    for (i = 0; i < count; i++)
+    {
+        seq_printf(s, "%s %d\n", g_nv_cap_mig_table[i].name,
+                   g_nv_cap_mig_table[i].minor);
+    }
+
+    index = 0;
+    count = NV_CAP_NUM_ENTRIES(g_nv_cap_mig_gpu_table) / NV_CAP_MAX_GPUS;
+    for (i = 0; i < NV_CAP_MAX_GPUS; i++)
+    {
+        for (j = 0; j < count; j++)
+        {
+            seq_printf(s, "gpu%d/%s %d\n", i,
+                       g_nv_cap_mig_gpu_table[index].name,
+                       g_nv_cap_mig_gpu_table[index].minor);
+            index++;
+        }
+    }
+
+    return 0;
+}
+
+NV_DEFINE_SINGLE_PROCFS_FILE(nvlink_minors,
+                             NV_READ_LOCK_SYSTEM_PM_LOCK_INTERRUPTIBLE,
+                             NV_READ_UNLOCK_SYSTEM_PM_LOCK);
+
+NV_DEFINE_SINGLE_PROCFS_FILE(mig_minors,
+                             NV_READ_LOCK_SYSTEM_PM_LOCK_INTERRUPTIBLE,
+                             NV_READ_UNLOCK_SYSTEM_PM_LOCK);
+
+static void nv_cap_procfs_exit(void)
+{
+    if (!nv_cap_procfs_dir)
+    {
+        return;
+    }
+
+    nv_procfs_unregister_all(nv_cap_procfs_dir, nv_cap_procfs_dir);
+    nv_cap_procfs_dir = NULL;
+}
+
+int nv_cap_procfs_init(void)
+{
+    nv_cap_procfs_dir = NV_CREATE_PROC_DIR(NV_CAP_PROCFS_DIR, NULL);
+    if (nv_cap_procfs_dir == NULL)
+    {
+        return -EACCES;
+    }
+
+    nv_cap_procfs_mig_minors = NV_CREATE_PROC_FILE("mig-minors",
+                                                   nv_cap_procfs_dir,
+                                                   mig_minors,
+                                                   NULL);
+    if (nv_cap_procfs_mig_minors == NULL)
+    {
+        goto cleanup;
+    }
+
+    nv_cap_procfs_nvlink_minors = NV_CREATE_PROC_FILE("nvlink-minors",
+                                                      nv_cap_procfs_dir,
+                                                      nvlink_minors,
+                                                      NULL);
+    if (nv_cap_procfs_nvlink_minors == NULL)
+    {
+        goto cleanup;
+    }
+
+    return 0;
+
+cleanup:
+    nv_cap_procfs_exit();
+
+    return -EACCES;
+}
+
+static int nv_cap_find_minor_in_table(nv_cap_table_entry_t *table, int count,
+                                      const char *target)
+{
+    int i;
+
+    for (i = 0; i < count; i++)
+    {
+        if (strcmp(table[i].name, target) == 0)
+        {
+            return table[i].minor;
+        }
+    }
+
+    return -1;
+}
+
+static int nv_cap_find_minor(char *path)
+{
+    char *target;
+    int minor;
+    unsigned int len, count, gpu, index;
+
+    target = "/driver/nvidia-nvlink/capabilities/";
+    len = strlen(target);
+
+    if (strncmp(path, target, len) == 0)
+    {
+        target = path + len;
+        count = NV_CAP_NUM_ENTRIES(g_nv_cap_nvlink_table);
+        minor = nv_cap_find_minor_in_table(g_nv_cap_nvlink_table,
+                                           count, target);
+        if (minor >= 0)
+        {
+            return minor;
+        }
+    }
+
+    target = "/driver/nvidia/capabilities/gpu";
+    len = strlen(target);
+
+    if (strncmp(path, target, len) == 0)
+    {
+        target = path + len;
+        sscanf(target, "%u\n", &gpu);
+        target = strchr(target, '/');
+        WARN_ON(gpu >= NV_CAP_MAX_GPUS);
+        WARN_ON(target == NULL);
+
+        len = strlen("/mig/");
+        if (strncmp(target, "/mig/", len) == 0)
+        {
+            target = target + len;
+            count = NV_CAP_NUM_ENTRIES(g_nv_cap_mig_gpu_table) / NV_CAP_MAX_GPUS;
+            index = gpu * count;
+            minor = nv_cap_find_minor_in_table(&g_nv_cap_mig_gpu_table[index],
+                                               count, target);
+            if (minor >= 0)
+            {
+                return minor;
+            }
+        }
+    }
+
+    target = "/driver/nvidia/capabilities/mig/";
+    len = strlen(target);
+
+    if (strncmp(path, target, len) == 0)
+    {
+        target = path + len;
+
+        count = NV_CAP_NUM_ENTRIES(g_nv_cap_mig_table);
+        minor = nv_cap_find_minor_in_table(g_nv_cap_mig_table, count, target);
+        if (minor >= 0)
+        {
+            return minor;
+        }
+    }
+
+    return -1;
+}
+
+static void nv_cap_assign_minors(void)
+{
+    int minor = 0;
+    int count;
+    int i;
+
+    count = NV_CAP_NUM_ENTRIES(g_nv_cap_nvlink_table);
+    for (i = 0; i < count; i++)
+    {
+        g_nv_cap_nvlink_table[i].minor = minor++;
+    }
+
+    count = NV_CAP_NUM_ENTRIES(g_nv_cap_mig_table);
+    for (i = 0; i < count; i++)
+    {
+        g_nv_cap_mig_table[i].minor = minor++;
+    }
+
+    count = NV_CAP_NUM_ENTRIES(g_nv_cap_mig_gpu_table);
+    for (i = 0; i < count; i++)
+    {
+        g_nv_cap_mig_gpu_table[i].minor = minor++;
+    }
+
+    WARN_ON(minor > NV_CAP_DRV_MINOR_COUNT);
+}
+
+static ssize_t nv_cap_procfs_write(struct file *file,
+                                    const char __user *buffer,
+                                    size_t count, loff_t *pos)
+{
+    nv_cap_file_private_t *private = NULL;
+    unsigned long bytes_left;
+    char *proc_buffer;
+
+    private = ((struct seq_file *)file->private_data)->private;
+    bytes_left = (sizeof(private->buffer) - private->offset - 1);
+
+    if (count == 0)
+    {
+        return -EINVAL;
+    }
+
+    if ((bytes_left == 0) || (count > bytes_left))
+    {
+        return -ENOSPC;
+    }
+
+    proc_buffer = &private->buffer[private->offset];
+
+    if (copy_from_user(proc_buffer, buffer, count))
+    {
+        nv_printf(NV_DBG_ERRORS, "nv-caps: failed to copy in proc data!\n");
+        return -EFAULT;
+    }
+
+    private->offset += count;
+    proc_buffer[count] = '\0';
+
+    *pos = private->offset;
+
+    return count;
+}
+
+static int nv_cap_procfs_read(struct seq_file *s, void *v)
+{
+    nv_cap_file_private_t *private = s->private;
+
+    if (nv_cap_enable_devfs)
+    {
+        seq_printf(s, "%s: %d\n", "DeviceFileMinor", private->minor);
+        seq_printf(s, "%s: %d\n", "DeviceFileMode", private->permissions);
+        seq_printf(s, "%s: %d\n", "DeviceFileModify", private->modify);
+    }
+
+    return 0;
+}
+
+static int nv_cap_procfs_open(struct inode *inode, struct file *file)
+{
+    nv_cap_file_private_t *private = NULL;
+    int rc;
+    nv_cap_t *cap = NV_PDE_DATA(inode);
+
+    NV_KMALLOC(private, sizeof(nv_cap_file_private_t));
+    if (private == NULL)
+    {
+        return -ENOMEM;
+    }
+
+    /* Just copy over data for "fd" validation */
+    private->files = current->files;
+    private->minor = cap->minor;
+    private->permissions = cap->permissions;
+    private->offset = 0;
+    private->modify = cap->modify;
+
+    rc = single_open(file, nv_cap_procfs_read, private);
+    if (rc < 0)
+    {
+        NV_KFREE(private, sizeof(nv_cap_file_private_t));
+        return rc;
+    }
+
+    rc = NV_READ_LOCK_SYSTEM_PM_LOCK_INTERRUPTIBLE();
+    if (rc < 0)
+    {
+        single_release(inode, file);
+        NV_KFREE(private, sizeof(nv_cap_file_private_t));
+    }
+
+    return rc;
+}
+
+static int nv_cap_procfs_release(struct inode *inode, struct file *file)
+{
+    struct seq_file *s = file->private_data;
+    nv_cap_file_private_t *private = NULL;
+    char *buffer;
+    int modify;
+    nv_cap_t *cap = NV_PDE_DATA(inode);
+
+    if (s != NULL)
+    {
+        private = s->private;
+    }
+
+    NV_READ_UNLOCK_SYSTEM_PM_LOCK();
+
+    single_release(inode, file);
+
+    if (private != NULL)
+    {
+        buffer = private->buffer;
+
+        if (private->offset != 0)
+        {
+            if (sscanf(buffer, "DeviceFileModify: %d", &modify) == 1)
+            {
+                cap->modify = modify;
+            }
+        }
+
+        NV_KFREE(private, sizeof(nv_cap_file_private_t));
+    }
+
+    /*
+     * All open files using the proc entry will be invalidated
+     * if the entry is removed.
+     */
+    file->private_data = NULL;
+
+    return 0;
+}
+
+static nv_proc_ops_t g_nv_cap_procfs_fops = {
+    NV_PROC_OPS_SET_OWNER()
+    .NV_PROC_OPS_OPEN    = nv_cap_procfs_open,
+    .NV_PROC_OPS_RELEASE = nv_cap_procfs_release,
+    .NV_PROC_OPS_WRITE   = nv_cap_procfs_write,
+    .NV_PROC_OPS_READ    = seq_read,
+    .NV_PROC_OPS_LSEEK   = seq_lseek,
+};
+
+/* forward declaration of g_nv_cap_drv_fops */
+static struct file_operations g_nv_cap_drv_fops;
+
+int NV_API_CALL nv_cap_validate_and_dup_fd(const nv_cap_t *cap, int fd)
+{
+    struct file *file;
+    int dup_fd;
+    const nv_cap_file_private_t *private = NULL;
+    struct inode *inode = NULL;
+    dev_t rdev = 0;
+
+    if (cap == NULL)
+    {
+        return -1;
+    }
+
+    file = fget(fd);
+    if (file == NULL)
+    {
+        return -1;
+    }
+
+    inode = NV_FILE_INODE(file);
+    if (inode == NULL)
+    {
+        goto err;
+    }
+
+    if (nv_cap_enable_devfs)
+    {
+        /* Make sure the fd belongs to the nv-cap-drv */
+        if (file->f_op != &g_nv_cap_drv_fops)
+        {
+            goto err;
+        }
+
+        /* Make sure the fd has the expected capability */
+        rdev = inode->i_rdev;
+        if (MINOR(rdev) != cap->minor)
+        {
+            goto err;
+        }
+
+        private = file->private_data;
+    }
+    else
+    {
+        /*
+         * Make sure the fd belongs to procfs and validate the associated
+         * capability; the NV_PDE_DATA(inode) check ensures this file was created
+         * by nv_cap_create_file_entry().
+         */
+        if ((strcmp(inode->i_sb->s_type->name, "proc") != 0) ||
+            (NV_PDE_DATA(inode) != cap))
+        {
+            goto err;
+        }
+
+        private = ((struct seq_file *)file->private_data)->private;
+    }
+
+    /* Make sure the fd is not duped during fork() */
+    if ((private == NULL) ||
+        (private->files != current->files))
+    {
+        goto err;
+    }
+
+    dup_fd = NV_GET_UNUSED_FD_FLAGS(O_CLOEXEC);
+    if (dup_fd < 0)
+    {
+          dup_fd = NV_GET_UNUSED_FD();
+          if (dup_fd < 0)
+          {
+               goto err;
+          }
+    }
+
+    fd_install(dup_fd, file);
+    return dup_fd;
+
+err:
+    fput(file);
+    return -1;
+}
+
+void NV_API_CALL nv_cap_close_fd(int fd)
+{
+    if (fd == -1)
+    {
+        return;
+    }
+
+    /*
+     * Acquire task_lock as we access current->files explicitly (__close_fd)
+     * and implicitly (sys_close), and it will race with the exit path.
+     */
+    task_lock(current);
+
+    /* Nothing to do, we are in exit path */
+    if (current->files == NULL)
+    {
+        task_unlock(current);
+        return;
+    }
+
+/*
+ * From v4.17-rc1 kernels have stopped exporting sys_close(fd) and started
+ * exporting __close_fd, as of this commit:
+ * 2018-04-02 2ca2a09d6215 ("fs: add ksys_close() wrapper; remove in-kernel
+ *  calls to sys_close()")
+ */
+#if NV_IS_EXPORT_SYMBOL_PRESENT___close_fd
+    __close_fd(current->files, fd);
+#else
+    sys_close(fd);
+#endif
+
+    task_unlock(current);
+}
+
+static nv_cap_t* nv_cap_alloc(nv_cap_t *parent_cap, const char *name)
+{
+    nv_cap_t *cap;
+    int len;
+
+    if (parent_cap == NULL || name == NULL)
+    {
+        return NULL;
+    }
+
+    NV_KMALLOC(cap, sizeof(nv_cap_t));
+    if (cap == NULL)
+    {
+        return NULL;
+    }
+
+    len = strlen(name) + strlen(parent_cap->path) + 2;
+    NV_KMALLOC(cap->path, len);
+    if (cap->path == NULL)
+    {
+        NV_KFREE(cap, sizeof(nv_cap_t));
+        return NULL;
+    }
+
+    strcpy(cap->path, parent_cap->path);
+    strcat(cap->path, "/");
+    strcat(cap->path, name);
+
+    len = strlen(name) + 1;
+    NV_KMALLOC(cap->name, len);
+    if (cap->name == NULL)
+    {
+        NV_KFREE(cap->path, strlen(cap->path) + 1);
+        NV_KFREE(cap, sizeof(nv_cap_t));
+        return NULL;
+    }
+
+    strcpy(cap->name, name);
+
+    cap->minor = -1;
+    cap->modify = NVreg_ModifyDeviceFiles;
+
+    return cap;
+}
+
+static void nv_cap_free(nv_cap_t *cap)
+{
+    if (cap == NULL)
+    {
+        return;
+    }
+
+    NV_KFREE(cap->path, strlen(cap->path) + 1);
+    NV_KFREE(cap->name, strlen(cap->name) + 1);
+    NV_KFREE(cap, sizeof(nv_cap_t));
+}
+
+nv_cap_t* NV_API_CALL nv_cap_create_file_entry(nv_cap_t *parent_cap,
+                                               const char *name, int mode)
+{
+    nv_cap_t *cap = NULL;
+    int minor;
+
+    cap = nv_cap_alloc(parent_cap, name);
+    if (cap == NULL)
+    {
+        return NULL;
+    }
+
+    cap->parent = parent_cap->entry;
+    cap->permissions = mode;
+
+    /* Make proc entries world visible if devfs is enabled */
+    if (nv_cap_enable_devfs)
+    {
+        mode = (S_IFREG | S_IRUGO);
+    }
+    else
+    {
+        mode |= S_IFREG;
+    }
+
+    minor = nv_cap_find_minor(cap->path);
+    if (minor < 0)
+    {
+        nv_cap_free(cap);
+        return NULL;
+    }
+
+    cap->minor = minor;
+
+    cap->entry = proc_create_data(name, mode, parent_cap->entry,
+                                  &g_nv_cap_procfs_fops, (void*)cap);
+    if (cap->entry == NULL)
+    {
+        nv_cap_free(cap);
+        return NULL;
+    }
+
+    return cap;
+}
+
+nv_cap_t* NV_API_CALL nv_cap_create_dir_entry(nv_cap_t *parent_cap,
+                                              const char *name, int mode)
+{
+    nv_cap_t *cap = NULL;
+
+    cap = nv_cap_alloc(parent_cap, name);
+    if (cap == NULL)
+    {
+        return NULL;
+    }
+
+    cap->parent = parent_cap->entry;
+    cap->permissions = mode;
+    cap->minor = -1;
+
+    /* Make proc entries world visible if devfs is enabled */
+    if (nv_cap_enable_devfs)
+    {
+        mode = (S_IFDIR | S_IRUGO | S_IXUGO);
+    }
+    else
+    {
+        mode |= S_IFDIR;
+    }
+
+    cap->entry = NV_PROC_MKDIR_MODE(name, mode, parent_cap->entry);
+    if (cap->entry == NULL)
+    {
+        nv_cap_free(cap);
+        return NULL;
+    }
+
+    return cap;
+}
+
+nv_cap_t* NV_API_CALL nv_cap_init(const char *path)
+{
+    nv_cap_t parent_cap;
+    nv_cap_t *cap;
+    int mode;
+    char *name = NULL;
+    char dir[] = "/capabilities";
+
+    if (path == NULL)
+    {
+        return NULL;
+    }
+
+    NV_KMALLOC(name, (strlen(path) + strlen(dir)) + 1);
+    if (name == NULL)
+    {
+        return NULL;
+    }
+
+    strcpy(name, path);
+    strcat(name, dir);
+    parent_cap.entry = NULL;
+    parent_cap.path = "";
+    parent_cap.name = "";
+    mode =  S_IRUGO | S_IXUGO;
+    cap = nv_cap_create_dir_entry(&parent_cap, name, mode);
+
+    NV_KFREE(name, strlen(name) + 1);
+    return cap;
+}
+
+void NV_API_CALL nv_cap_destroy_entry(nv_cap_t *cap)
+{
+    if (WARN_ON(cap == NULL))
+    {
+        return;
+    }
+
+    remove_proc_entry(cap->name, cap->parent);
+    nv_cap_free(cap);
+}
+
+static int nv_cap_drv_open(struct inode *inode, struct file *file)
+{
+    nv_cap_file_private_t *private = NULL;
+
+    NV_KMALLOC(private, sizeof(nv_cap_file_private_t));
+    if (private == NULL)
+    {
+        return -ENOMEM;
+    }
+
+    /* Just copy over data for "fd" validation */
+    private->files = current->files;
+    file->private_data = private;
+
+    return 0;
+}
+
+static int nv_cap_drv_release(struct inode *inode, struct file *file)
+{
+    if (file->private_data != NULL)
+    {
+        NV_KFREE(file->private_data, sizeof(nv_cap_file_private_t));
+
+        file->private_data = NULL;
+    }
+
+    return 0;
+}
+
+static struct file_operations g_nv_cap_drv_fops =
+{
+    .owner = THIS_MODULE,
+    .open    = nv_cap_drv_open,
+    .release = nv_cap_drv_release
+};
+
+int NV_API_CALL nv_cap_drv_init(void)
+{
+    int rc;
+
+    nv_cap_assign_minors();
+
+    if (!nv_cap_enable_devfs)
+    {
+        nv_printf(NV_DBG_INFO, "nv-caps-drv is disabled.\n");
+        return 0;
+    }
+
+    if (g_nv_cap_drv.initialized)
+    {
+        nv_printf(NV_DBG_ERRORS, "nv-caps-drv is already initialized.\n");
+        return -EBUSY;
+    }
+
+    rc = alloc_chrdev_region(&g_nv_cap_drv.devno,
+                             0,
+                             NV_CAP_DRV_MINOR_COUNT,
+                             "nvidia-caps");
+    if (rc < 0)
+    {
+        nv_printf(NV_DBG_ERRORS, "nv-caps-drv failed to create cdev region.\n");
+        return rc;
+    }
+
+    cdev_init(&g_nv_cap_drv.cdev, &g_nv_cap_drv_fops);
+
+    g_nv_cap_drv.cdev.owner = THIS_MODULE;
+
+    rc = cdev_add(&g_nv_cap_drv.cdev, g_nv_cap_drv.devno,
+                  NV_CAP_DRV_MINOR_COUNT);
+    if (rc < 0)
+    {
+        nv_printf(NV_DBG_ERRORS, "nv-caps-drv failed to create cdev.\n");
+        goto cdev_add_fail;
+    }
+
+    rc = nv_cap_procfs_init();
+    if (rc < 0)
+    {
+        nv_printf(NV_DBG_ERRORS, "nv-caps-drv: unable to init proc\n");
+        goto proc_init_fail;
+    }
+
+    g_nv_cap_drv.initialized = NV_TRUE;
+
+    return 0;
+
+proc_init_fail:
+    cdev_del(&g_nv_cap_drv.cdev);
+
+cdev_add_fail:
+    unregister_chrdev_region(g_nv_cap_drv.devno, NV_CAP_DRV_MINOR_COUNT);
+
+    return rc;
+}
+
+void NV_API_CALL nv_cap_drv_exit(void)
+{
+    if (!g_nv_cap_drv.initialized)
+    {
+        return;
+    }
+
+    nv_cap_procfs_exit();
+
+    cdev_del(&g_nv_cap_drv.cdev);
+
+    unregister_chrdev_region(g_nv_cap_drv.devno, NV_CAP_DRV_MINOR_COUNT);
+
+    g_nv_cap_drv.initialized = NV_FALSE;
+}
diff -ruN a/kernel/nvidia/nv-pci.c b/kernel/nvidia/nv-pci.c
--- a/kernel/nvidia/nv-pci.c	2020-08-19 15:16:30.930000614 +0200
+++ b/kernel/nvidia/nv-pci.c	2020-08-19 15:18:13.180000809 +0200
@@ -423,7 +423,7 @@
     pci_set_master(pci_dev);
 
 #if defined(CONFIG_VGA_ARB) && !defined(NVCPU_PPC64LE)
-#if defined(VGA_DEFAULT_DEVICE)
+#if defined(NV_VGA_TRYGET_PRESENT) && defined(VGA_DEFAULT_DEVICE)
     vga_tryget(VGA_DEFAULT_DEVICE, VGA_RSRC_LEGACY_MASK);
 #endif
     vga_set_legacy_decoding(pci_dev, VGA_RSRC_NONE);
diff -ruN a/kernel/nvidia/nvidia.Kbuild b/kernel/nvidia/nvidia.Kbuild
--- a/kernel/nvidia/nvidia.Kbuild	2020-08-19 15:16:30.870000614 +0200
+++ b/kernel/nvidia/nvidia.Kbuild	2020-08-19 15:19:56.570001006 +0200
@@ -146,6 +146,7 @@
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += jiffies_to_timespec
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += ktime_get_raw_ts64
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += ktime_get_real_ts64
+NV_CONFTEST_FUNCTION_COMPILE_TESTS += vga_tryget
 
 NV_CONFTEST_SYMBOL_COMPILE_TESTS += is_export_symbol_gpl_of_node_to_nid
 NV_CONFTEST_SYMBOL_COMPILE_TESTS += is_export_symbol_gpl_sme_active
diff -ruN a/kernel/nvidia-drm/nvidia-drm-drv.c b/kernel/nvidia-drm/nvidia-drm-drv.c
--- a/kernel/nvidia-drm/nvidia-drm-drv.c	2020-08-19 15:16:30.820000614 +0200
+++ b/kernel/nvidia-drm/nvidia-drm-drv.c	2020-08-19 15:18:13.180000809 +0200
@@ -473,16 +473,25 @@
 
 #if defined(NV_DRM_ATOMIC_MODESET_AVAILABLE)
 
+#if defined(NV_DRM_MASTER_SET_RETURNS_INT)
 static int nv_drm_master_set(struct drm_device *dev,
                              struct drm_file *file_priv, bool from_open)
+#else
+static void nv_drm_master_set(struct drm_device *dev,
+                              struct drm_file *file_priv, bool from_open)
+#endif
 {
     struct nv_drm_device *nv_dev = to_nv_device(dev);
 
+#if defined(NV_DRM_MASTER_SET_RETURNS_INT)
     if (!nvKms->grabOwnership(nv_dev->pDevice)) {
         return -EINVAL;
     }
 
     return 0;
+#else
+    nvKms->grabOwnership(nv_dev->pDevice);
+#endif
 }
 
 #if defined(NV_DRM_MASTER_DROP_HAS_FROM_RELEASE_ARG)
@@ -719,7 +728,11 @@
 #endif
                                DRIVER_GEM  | DRIVER_RENDER,
 
+#if defined(NV_DRM_DRIVER_HAS_GEM_FREE_OBJECT)
     .gem_free_object        = nv_drm_gem_free,
+#else
+    .gem_free_object_unlocked = nv_drm_gem_free,
+#endif
 
     .ioctls                 = nv_drm_ioctls,
     .num_ioctls             = ARRAY_SIZE(nv_drm_ioctls),
diff -ruN a/kernel/nvidia-drm/nvidia-drm-gem.h b/kernel/nvidia-drm/nvidia-drm-gem.h
--- a/kernel/nvidia-drm/nvidia-drm-gem.h	2020-08-19 15:16:30.820000614 +0200
+++ b/kernel/nvidia-drm/nvidia-drm-gem.h	2020-08-19 15:18:13.180000809 +0200
@@ -96,8 +96,12 @@
 nv_drm_gem_object_unreference_unlocked(struct nv_drm_gem_object *nv_gem)
 {
 #if defined(NV_DRM_GEM_OBJECT_GET_PRESENT)
+#if defined(NV_DRM_GEM_OBJECT_PUT_UNLOCKED_PRESENT)
     drm_gem_object_put_unlocked(&nv_gem->base);
 #else
+    drm_gem_object_put(&nv_gem->base);
+#endif
+#else
     drm_gem_object_unreference_unlocked(&nv_gem->base);
 #endif
 }
@@ -145,7 +149,6 @@
 #if defined(NV_DRM_GEM_OBJECT_HAS_RESV)
     nv_gem->base.resv = &nv_gem->resv;
 #endif
-
 #endif
 
     drm_gem_private_object_init(dev, &nv_gem->base, size);
diff -ruN a/kernel/nvidia-drm/nvidia-drm-utils.c b/kernel/nvidia-drm/nvidia-drm-utils.c
--- a/kernel/nvidia-drm/nvidia-drm-utils.c	2020-08-19 15:16:30.820000614 +0200
+++ b/kernel/nvidia-drm/nvidia-drm-utils.c	2020-08-19 15:18:13.180000809 +0200
@@ -103,7 +103,9 @@
 nvkms_display_mode_to_drm_mode(const struct NvKmsKapiDisplayMode *displayMode,
                                struct drm_display_mode *mode)
 {
+#if defined(NV_DRM_DISPLAY_MODE_HAS_VREFRESH)
     mode->vrefresh    = (displayMode->timings.refreshRate + 500) / 1000; /* In Hz */
+#endif
 
     mode->clock       = (displayMode->timings.pixelClockHz + 500) / 1000; /* In Hz */
 
@@ -159,7 +161,9 @@
 void drm_mode_to_nvkms_display_mode(const struct drm_display_mode *src,
                                     struct NvKmsKapiDisplayMode *dst)
 {
+#if defined(NV_DRM_DISPLAY_MODE_HAS_VREFRESH)
     dst->timings.refreshRate  = src->vrefresh * 1000;
+#endif
 
     dst->timings.pixelClockHz = src->clock * 1000; /* In Hz */
 
diff -ruN a/kernel/nvidia-drm/nvidia-drm.Kbuild b/kernel/nvidia-drm/nvidia-drm.Kbuild
--- a/kernel/nvidia-drm/nvidia-drm.Kbuild	2020-08-19 15:16:30.820000614 +0200
+++ b/kernel/nvidia-drm/nvidia-drm.Kbuild	2020-08-19 15:18:13.180000809 +0200
@@ -50,6 +50,7 @@
 
 NV_CONFTEST_GENERIC_COMPILE_TESTS += drm_available
 NV_CONFTEST_GENERIC_COMPILE_TESTS += drm_atomic_available
+NV_CONFTEST_GENERIC_COMPILE_TESTS += drm_master_set_returns_int
 NV_CONFTEST_GENERIC_COMPILE_TESTS += is_export_symbol_gpl_refcount_inc
 NV_CONFTEST_GENERIC_COMPILE_TESTS += is_export_symbol_gpl_refcount_dec_and_test
 NV_CONFTEST_GENERIC_COMPILE_TESTS += drm_alpha_blending_available
@@ -59,6 +60,7 @@
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += get_user_pages_remote
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += get_user_pages
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_gem_object_lookup
+NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_gem_object_put_unlocked
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_atomic_state_ref_counting
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_driver_has_gem_prime_res_obj
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += drm_atomic_helper_connector_dpms
@@ -75,6 +77,8 @@
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_bus_has_get_irq
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_bus_has_get_name
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_driver_has_legacy_dev_list
+NV_CONFTEST_TYPE_COMPILE_TESTS += drm_driver_has_gem_free_object
+NV_CONFTEST_TYPE_COMPILE_TESTS += drm_display_mode_has_vrefresh
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_driver_has_set_busid
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_crtc_state_has_connectors_changed
 NV_CONFTEST_TYPE_COMPILE_TESTS += drm_init_function_args
diff -ruN a/kernel/nvidia-uvm/nvidia-uvm.Kbuild b/kernel/nvidia-uvm/nvidia-uvm.Kbuild
--- a/kernel/nvidia-uvm/nvidia-uvm.Kbuild	2020-08-19 15:16:30.830000614 +0200
+++ b/kernel/nvidia-uvm/nvidia-uvm.Kbuild	2020-08-19 15:18:13.180000809 +0200
@@ -99,6 +99,7 @@
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += set_pages_uc
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += acpi_walk_namespace
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += ktime_get_raw_ts64
+NV_CONFTEST_FUNCTION_COMPILE_TESTS += smp_read_barrier_depends
 
 NV_CONFTEST_TYPE_COMPILE_TESTS += outer_flush_all
 NV_CONFTEST_TYPE_COMPILE_TESTS += file_operations
diff -ruN a/kernel/nvidia-uvm/uvm8_tools.c b/kernel/nvidia-uvm/uvm8_tools.c
--- a/kernel/nvidia-uvm/uvm8_tools.c	2020-08-19 15:16:30.840000614 +0200
+++ b/kernel/nvidia-uvm/uvm8_tools.c	2020-08-19 15:18:13.180000809 +0200
@@ -192,7 +192,11 @@
 {
     long event_tracker = atomic_long_read((atomic_long_t *)&filp->private_data);
 
+#if defined(NV_SMP_READ_BARRIER_DEPENDS_PRESENT)
     smp_read_barrier_depends();
+#else
+    smp_rmb();
+#endif
     return (uvm_tools_event_tracker_t *)event_tracker;
 }
 
diff -ruN a/kernel/nvidia-uvm/uvm8_va_range.h b/kernel/nvidia-uvm/uvm8_va_range.h
--- a/kernel/nvidia-uvm/uvm8_va_range.h	2020-08-19 15:16:30.850000614 +0200
+++ b/kernel/nvidia-uvm/uvm8_va_range.h	2020-08-19 15:18:13.180000809 +0200
@@ -755,7 +755,11 @@
     // make sure that any initialization of this block by the creating thread is
     // visible to later accesses in this thread, which requires a data
     // dependency barrier.
+#if defined(NV_SMP_READ_BARRIER_DEPENDS_PRESENT)
     smp_read_barrier_depends();
+#else
+    smp_mb();
+#endif
     return block;
 }
 
